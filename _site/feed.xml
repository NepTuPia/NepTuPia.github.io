<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-07T00:55:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Footprints</title><subtitle>My milestones are here</subtitle><author><name>Kim Namsub</name></author><entry><title type="html">Unity programming(4)</title><link href="http://localhost:4000/Unity-Programming(4)/" rel="alternate" type="text/html" title="Unity programming(4)" /><published>2022-02-06T00:00:00+09:00</published><updated>2022-02-06T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(4)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(4)/">&lt;h1 id=&quot;5-게임-오브젝트-제어하기&quot;&gt;5. 게임 오브젝트 제어하기&lt;/h1&gt;

&lt;p&gt;객체지향을 이용해 클래스와 오브젝트(객체)를 다뤄보자&lt;/p&gt;

&lt;h2 id=&quot;클래스와-오브젝트&quot;&gt;클래스와 오브젝트&lt;/h2&gt;
&lt;p&gt;게임내에서의 지형, NPC, 몬스터 하나하나는 오브젝트(객체)다. 그리고 이 오브젝트들은 클래스를 통해 하나씩 생성되어 게임 내에서 사용된다.&lt;/p&gt;

&lt;p&gt;즉 객체지향과 동일하다.&lt;/p&gt;

&lt;p&gt;같은 클래스에서 찍어낸 각각의 오브젝트는 물론 다른 클래스에서 나온 오브젝트끼리는 독립성을 지닌다. 한 오브젝트가 어떤 행동할 하거나 죽는 것이 다른 오브젝트에 영향을 미치지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;c-클래스-만들기&quot;&gt;C# 클래스 만들기&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;539&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152676713-029f8572-f07a-4475-84cd-d356d7e63375.png&quot; /&gt;
Unity에서 C# 스크립트 만들기
&lt;/p&gt;

&lt;p&gt;위의 경로를 통해 C# 스크립트를 만들면 유니티의 Asset에 만든 스크립트 파일이 보인다. 해당 스크립트 파일을 클릭하면 IDE를 통해 C# 코드를 작성하고 저장할 수 있다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;480&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152676938-871b6fe1-fa88-42e8-bf15-86b932e743f9.png&quot; /&gt;
C# 스크립트
&lt;/p&gt;

&lt;p&gt;Animal 클래스를 만들고 필드 변수로 이름(name)과 울음소리(sound) 그리고 메서드로 이름과 울음소리를 로그로 찍도록 만들었다.&lt;/p&gt;

&lt;p&gt;현재 MonoBehaviour 클래스를 Animal 클래스가 상속받지 않아 실제 Unity에서 컴포넌트로 만들 수 없다.&lt;/p&gt;

&lt;p&gt;이제 Animal 클래스를 기반으로 Animal 오브젝트를 만드는 Zoo 스크립트를 만들자&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;425&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152685781-0a58248e-7e92-449d-9400-9da2aae0eb68.png&quot; /&gt;
Zoo 클래스
&lt;/p&gt;

&lt;p&gt;Animal 클래스의 객체인 Tom을 만들어 이름과 울음소리를 설정하고 메서드를 실행시키는 스크립트, MonoBehaviour을 상속받으므로 Unity에서 컴포넌트로 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 Hierarchy 창에서 Create &amp;gt; Create empty로 빈 오브젝트를 만들고 만들어진 컴포넌트에 Zoo 스크립트를 Drag&amp;amp;Drop을 하면 컴포넌트로 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 실행을 해보면 console에 로그로 “냐옹!”이 찍히는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1176&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152686020-8520e00c-637d-401f-8dad-62240e30c41c.png&quot; /&gt;
Zoo 컴포넌트를 담은 오브젝트 실행 결과
&lt;/p&gt;

&lt;h2 id=&quot;참조타입에-대한-고찰&quot;&gt;*참조타입에 대한 고찰&lt;/h2&gt;
&lt;p&gt;Tom 말고 Jerry라는 Animal 오브젝트를 Zoo 스크립트안에서 만든 뒤 name을 jerry, sound를 찍찍!으로 설정해보자.&lt;/p&gt;

&lt;p&gt;그리고&lt;/p&gt;

&lt;p&gt;jerry = tom;&lt;/p&gt;

&lt;p&gt;이라는 코드를 입력해보자.&lt;/p&gt;

&lt;p&gt;jerry, tom같은 객체명은 참조타입이기에 jerry, tom이 각각 가지고 있는 멤버들의 메모리 주소를 지니게 된다. jerry와 tom을 통해 해당 메모리에 접근할 수 있는 것이다(포인터처럼)&lt;/p&gt;

&lt;p&gt;jerry = tom;&lt;/p&gt;

&lt;p&gt;jerry.name = “제리”;&lt;/p&gt;

&lt;p&gt;를 실행하면 jerry는 tom의 멤버를 가리키게 되고 그 후 jerry를 통해 name을 수정하게 되면&lt;/p&gt;

&lt;p&gt;tom.name도 “제리”로 변경되게 된다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;538&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152686569-a04b85f6-9a4a-43f3-94ae-4f4e0202ef52.png&quot; /&gt;
위 내용을 담은 Zoo 스크립트 코드
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;433&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152686733-841714e4-c410-4937-b4d4-9dde0b662832.png&quot; /&gt;
스크립트 코드 실행 console 결과
&lt;/p&gt;

&lt;p&gt;그 결과 위의 그림처럼 jerry를 통해 tom의 name이 수정된 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;객체지향의 참조타입(reference type)과 원시타입(primitive type)의 중요한 차이점을 알 수 있는 내용이라 따로 정리해보았다.&lt;/p&gt;

&lt;h2 id=&quot;변수로-컴포넌트-사용하기&quot;&gt;변수로 컴포넌트 사용하기&lt;/h2&gt;

&lt;p&gt;변수의 타입을 참조타입으로 설정하면 변수를 통해 오브젝트와 컴포넌트에 접근해 이들을 조종할 수 있다. 이를 활용해보자&lt;/p&gt;

&lt;p&gt;우선 Hierarchy에서 Create &amp;gt; 3D object &amp;gt; Cube를 통해 큐브 오브젝트를 생성하고 생성한 큐브의 Inspector 창에서 Add component &amp;gt; Physics &amp;gt; Rigidbody 컴포넌트를 추가해 물리법칙에 영향을 받도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;변수로-rigidbody-컴포넌트-사용하기&quot;&gt;변수로 Rigidbody 컴포넌트 사용하기&lt;/h3&gt;
&lt;p&gt;참조타입의 변수로 오브젝트를 가리킬 수 있다.&lt;/p&gt;

&lt;p&gt;즉, Rigidbody 타입의 변수는 Rigidbody 컴포넌트를 가진 오브젝트를 가리키고 다룰 수 있다. (이를 통해 유니티의 컴포넌트들은 클래스로 만들어져 있다는 것을 알 수 있다!)&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;450&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152688425-75594778-cfbb-40e7-a70e-e6671b6b69a0.png&quot; /&gt;
Jumper 스크립트
&lt;/p&gt;

&lt;p&gt;Jumper C# 스크립트를 만들고 rigidbody 타입의 변수 myRigidBody를 만들어 AddForce 메서드를 실행하는 코드다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;450&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152688643-b248ea81-1684-4753-9363-86ac3cbddbe2.png&quot; /&gt;
추가한 Jumper 컴포넌트에 오브젝트 할당
&lt;/p&gt;

&lt;p&gt;이렇게 추가했으면 Jumper 스크립트의 컴포넌트를 Inspector창에서 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;스크립트상으로 public으로 선언된 변수는 Inspector창에서 만질 수 있는데 myRigidBody변수는 public이었으므로 Inspector창에 표시된다.&lt;/p&gt;

&lt;p&gt;myRigidBody.Addforce();&lt;/p&gt;

&lt;p&gt;위의 코드는 변수 myRigidBody가 가리키는 오브젝트에 접근해 Addforce() 메서드를 실행하는 코드인데 현재 아무런 오브젝트도 myRigidBody 변수에 할당되어 있지 않으므로 에러가 난다.&lt;/p&gt;

&lt;p&gt;위의 그림처럼 Cube 오브젝트와 Jumper 컴포넌트의 Rigidbody타입 변수에 할당해주면 정상적으로 실행된다.&lt;/p&gt;

&lt;p&gt;즉 위처럼 Jumper 스크립트의 myRigidBody변수에서 실제 큐브 오브젝트의 Rigidbody 컴포넌트로 향하는 참조가 할당된다.&lt;/p&gt;

&lt;p&gt;여기서는 변수 myRigidBody가 실제로 사용되는 것이 아니라 myRigidBody가 가리키는 실체(큐브 오브젝트의 Rigidbody 컴포넌트)가 사용된다는 점에 주목하자.&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">5. 게임 오브젝트 제어하기</summary></entry><entry><title type="html">Unitiy programming(3)</title><link href="http://localhost:4000/Unitiy-Programming(3)/" rel="alternate" type="text/html" title="Unitiy programming(3)" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/Unitiy%20Programming(3)</id><content type="html" xml:base="http://localhost:4000/Unitiy-Programming(3)/">&lt;h1 id=&quot;2-상속과-컴포넌트&quot;&gt;2. 상속과 컴포넌트&lt;/h1&gt;

&lt;p&gt;유니티는 기본적인 객체지향(OOP)의 특성인 상속과 게임 오브젝트 구성을 위해 상속보다 더 효과적인 컴포넌트 패턴이라는 것을 지원한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;상속&quot;&gt;상속&lt;/h3&gt;
&lt;p&gt;일반적인 객체지향에서의 상속과 동일하다. 부모클래스의 메소드와 필드를 자식개체가 물려받아 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;다만 Human 클래스를 만들어 이를 바탕으로 다양한 NPC를 만들고 몬스터 오브젝트를 만들려고 하면 인간 종족이 아닌 슬라임, 늑대인간 등 Human 클래스의 활용도가 현저히 떨어지는 상황이 게임을 개발하는 상황에서는 자주 발생한다.&lt;/p&gt;

&lt;p&gt;Human 클래스에서 인간에 맞춰 움직임과 그 그래픽, 상호작용을 구성해놨는데 이를 슬라임 등 다른 오브젝트에 사용하려고 하면 모두 다 메소드 오버로딩 등 재정의하거나 변경해야 하기에 그 효율이 떨어지는 것이다.&lt;/p&gt;

&lt;p&gt;즉, 상속만으로 게임개발을 하면&lt;br /&gt;
&lt;strong&gt;1. 오히려 코드의 재사용을 하기 힘든 경우가 발생&lt;/strong&gt; - 위의 경우 Slime, Warewolf 클래스 등 여러 클래스를 개별적으로 만들어줘야 함&lt;br /&gt;
&lt;strong&gt;2. 기획자가 새로운 오브젝트를 만들려면 프로그래머에게 의존해야 함&lt;/strong&gt; - 코드 수준에서만 부모 클래스를 확장하거나 자식 클래스에서 오버로딩 등을 할 수 있기에 다른 팀원이 접근하기 어려움&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 문제를 해결하기 위해 유니티는 ‘컴포넌트 패턴’을 활용한 개발을 지원한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;컴포넌트-패턴&quot;&gt;컴포넌트 패턴&lt;/h3&gt;
&lt;p&gt;게임 엔진에서 ‘오브젝트’는 게임 세상에 존재하는 하나의 물체이다. 유니티에서는 이 오브젝트를 ‘컴포넌트’를 사용해 만든다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Component (or Composition) 패턴&lt;/strong&gt; - 미리 만들어진 부품을 조립하여 물건을 만드는 것 처럼 이미 만들어진 컴포넌트들을 조합해 오브젝트를 만들어 나가는 방법&lt;/p&gt;

&lt;p&gt;기획자가 처음부터 게임에 등장할 모든 동물을 예상할 수 없기에 개발자는 공통적으로 쓰일 개별적인 컴포넌트를 만들어 둔다. 예를들어 팔, 다리, 아가미, 입, 코, 지느러미, 잠자기, 움직이기, 날개, 식사 등 독자적으로 쓰일 수 있는 것들을 만들어 둔다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;게임-오브젝트와-컴포넌트의-특징&quot;&gt;게임 오브젝트와 컴포넌트의 특징&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1. 유연한 재사용이 가능&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;2. 기획자의 프로그래머에 대한 의존성 감소&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;3. 뛰어난 독립성 덕분에 기능 추가와 삭제가 용이&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3-1. 게임 오브젝트는 단순한 껍데기&lt;/strong&gt; - 게임 오브젝트는 몇 가지의 식별기능과 어떠한 컴포넌트가 자신을 구성하고 있는지를 제외하고는 별다른 기능이 없음&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3-2. 컴포넌트는 개별적으로 작동하는 독립 부품임&lt;/strong&gt; - 컴포넌트는 다른 컴포넌트와 상관이 없음. 각 컴포넌트는 스스로 이미 완성되어 있기 때문에 한 오브젝트에서 컴포넌트를 추가 및 삭제해도 서로 충돌을 일으키거나 망가지지 않음&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;컴포넌트-추가-및-삭제&quot;&gt;컴포넌트 추가 및 삭제&lt;/h1&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1113&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/151705862-d8baa08e-2389-4847-b0aa-6974fe5f5fbb.png&quot; /&gt;
Cube 오브젝트와 이를 구성하는 컴포넌트들
&lt;/p&gt;

&lt;p&gt;위의 그림에서 Cube같은 오브젝트를 클릭하면 옆의 Inspector창에 선택한 오브젝트를 구성하는 컴포넌트들을 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;예를들어 Box collider 컴포넌트를 삭제하면 박스의 물리적 표면이 사라져 다른 물체와 충돌하지 않는다. 그리고 Rigidbody를 추가해 해당 오브젝트가 중력의 영향을 받도록 만들었다. 이 상태에서 Box collider 컴포넌트를 삭제하면 물리적 표면은 없지만 중력의 영향은 받기에 영원히 아래로 떨어지게 된다.&lt;/p&gt;

&lt;p&gt;즉 위에서 살펴보았던 것 처럼 컴포넌트 끼리의 독립성이 유지되는 것이다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;메시지와-브로드캐스팅&quot;&gt;메시지와 브로드캐스팅&lt;/h1&gt;

&lt;h2 id=&quot;monobehaviour&quot;&gt;MonoBehaviour&lt;/h2&gt;
&lt;p&gt;유니티의 모든 컴포넌트는 MonoBehaviour이라는 클래스를 상속받는다. 이 클래스는 유니티에서 미리 만들어 제공하는 클래스이며 컴포넌트에 필요한 필수적이고 기본적인 기능을 제공한다. 이를 상속한 컴포넌트만이 게임 오브젝트의 컴포넌트로서 사용될 수 있는 것이다. (파이썬의 self같은 느낌…?)&lt;/p&gt;

&lt;p&gt;그리고 이렇게 MonoBehaviour을 상속받은 컴포넌트는 유니티의 제어를 받게 되기에 유니티에서 보내는 메시지를 들을 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;broadcasting&quot;&gt;Broadcasting&lt;/h2&gt;
&lt;p&gt;유니티가 메시지를 보내면 컴포넌트들은 해당 메시지에서 호출된 메서드를 실행한다. 유니티는 메시지를 보낼 때 누가 받을지 상관하지 않으며 마찬가지로 컴포넌트들도 누가 보낸 메시지인지 신경쓰지 않는다. 그저 메시지에 적힌 메서드를 내가 가지고 있다면 실행하고 없다면 무시할 뿐이다.&lt;/p&gt;

&lt;p&gt;dance()라는 메서드를 실행하라는 메시지를 유니티가 컴포넌트들에게 방송하면 해당 메서드를 가지고 있는 컴포넌트들은 이에 반응하여 해당 메서드를 실행하고 그렇지 않는 컴포넌트들은 이를 무시한다.&lt;/p&gt;

&lt;h2 id=&quot;유니티-이벤트-메서드&quot;&gt;유니티 이벤트 메서드&lt;/h2&gt;
&lt;p&gt;위의 내용은 앞으로 많이 사용할 Start(), Update(), OnTriggerEnter()와 같은 ‘유니티 이벤트 메서드’가 동작하는 원리다. (이는 Unity programming(4)에서 다룰 예정)&lt;/p&gt;

&lt;p&gt;예를 들어 Start() 메서드는 오브젝트가 처음 활성화 될 때 자동으로 한번 실행되는데 이는 유니티가 Start라고 적힌 메서드를 자동으로 브로드캐스팅하기에 사용자가 명시적으로 호출할 필요가 없는 것이다.&lt;/p&gt;

&lt;p&gt;유니티에서는 이런 식으로 이름 철자만 똑같이 구현해두면 메시지와 브로드캐스팅에 의해 자동으로 실행되는 메서드들이 존재하고 이를 ‘유니티 이벤트 함수’ 혹은 ‘유니티 이벤트 메서드’라고 한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;요약&quot;&gt;요약&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1. 게임 오브젝트는 컴포넌트를 담는 단순한 빈 껍데기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 빈 게임 오브젝트에 컴포넌트를 붙여 기능을 추가한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 컴포넌트는 기능을 가진 부품으로 오브젝트에 이식되어 조립된다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 각 컴포넌트는 서로 독립적으로 작동한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 유니티의 모든 컴포넌트는 MonoBehaviour을 상속받아 만들어진다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 메시지를 받은 컴포넌트는 메시지에 표시된 메서드를 가지고 있으면 실행한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 브로드캐스팅은 메시지를 무차별적으로 모든 컴포넌트에게 뿌리는 행위이다&lt;/strong&gt;&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">2. 상속과 컴포넌트</summary></entry><entry><title type="html">게임 개발 개요 정리글</title><link href="http://localhost:4000/%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C-%EA%B0%9C%EC%9A%94-%EC%A0%95%EB%A6%AC%EA%B8%80/" rel="alternate" type="text/html" title="게임 개발 개요 정리글" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/%EA%B2%8C%EC%9E%84%20%EA%B0%9C%EB%B0%9C%20%EA%B0%9C%EC%9A%94%20%EC%A0%95%EB%A6%AC%EA%B8%80</id><content type="html" xml:base="http://localhost:4000/%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C-%EA%B0%9C%EC%9A%94-%EC%A0%95%EB%A6%AC%EA%B8%80/">&lt;h2 id=&quot;1-게임-기술-정리글&quot;&gt;1. 게임 기술 정리글&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;https://www.itfind.or.kr/WZIN/jugidong/1192/119206.htm&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">1. 게임 기술 정리글</summary></entry><entry><title type="html">Unity programming(1)</title><link href="http://localhost:4000/Unity-Programming(1)/" rel="alternate" type="text/html" title="Unity programming(1)" /><published>2021-12-30T00:00:00+09:00</published><updated>2021-12-30T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(1)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(1)/">&lt;h2 id=&quot;unity-시작하기&quot;&gt;Unity 시작하기&lt;/h2&gt;
&lt;p&gt;본 글은 “레트로의 유니티 게임 프로그래밍 에센스”를 따라가며 작성될 예정&lt;/p&gt;

&lt;p&gt;시작해보자!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68016394/147726564-2b883a83-a39e-41c0-a579-121ff5781403.jpg&quot; alt=&quot;unitybook&quot; /&gt;&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">Unity 시작하기 본 글은 “레트로의 유니티 게임 프로그래밍 에센스”를 따라가며 작성될 예정</summary></entry><entry><title type="html">Unity programming(2)</title><link href="http://localhost:4000/Unity-Programming(2)/" rel="alternate" type="text/html" title="Unity programming(2)" /><published>2021-12-30T00:00:00+09:00</published><updated>2021-12-30T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(2)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(2)/">&lt;h1 id=&quot;1-유니티-인터페이스&quot;&gt;1. 유니티 인터페이스&lt;/h1&gt;

&lt;p&gt;기본적인 유니티 인터페이스 설정을 해보고 살펴보자&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;초기화면-셋팅&quot;&gt;초기화면 셋팅&lt;/h3&gt;
&lt;p&gt;유니티 프로젝트를 열면 다음과 같은 모습이다.&lt;/p&gt;

&lt;p&gt;ㄹ&lt;/p&gt;

&lt;p&gt;이제 우측 상단의 ‘Default’라고 되어 있는 부분을 클릭해서 ‘2 by 3’로 바꿔주고
‘Project’ 탭을 ‘Hierarchy’ 탭 아래부분으로 이동하자.&lt;/p&gt;

&lt;p&gt;그리고 상단 맥북 메뉴에서 Windows &amp;gt; General &amp;gt; Console을 눌러 콘솔창을 띄운 뒤
‘Inspector’ 탭 아래에 넣어주어 기본적인 레이아웃 세팅을 완료하자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1174&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147740630-123620ec-1511-4288-8a0d-58c5ae7cedf9.png&quot; /&gt;
완료된 모습
&lt;/p&gt;

&lt;p&gt;위의 화면은 유니티에서 가장 많이 사용되는 메인 창 6개이며 좌측 위 사진부터 시계방향으로 다음과 같이 부른다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Scene&lt;/strong&gt;: 게임 월드인 씬을 시각적으로 편집하는 창&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Hierarchy&lt;/strong&gt;: 씬에 존재하는 모든 게임 오브젝트가 나열&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Inspector&lt;/strong&gt;: 선택한 오브젝트의 정보가 표시&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Console&lt;/strong&gt;: 로그나 에러가 표시&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Project&lt;/strong&gt;: 프로젝트에 사용될 asset들이 표시
(asset: 개발에 사용되는 모든 형태의 파일)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. Game&lt;/strong&gt;: 플레이어가 실제로 보게 될 화면&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;console-창-설명&quot;&gt;console 창 설명&lt;/h3&gt;

&lt;p&gt;아무래도 실제로 개발하다보면 디버깅이 가장 중요하기에 따로 정리해본다&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147742237-3be108a4-7ebc-4264-963b-e372e73db4fd.png&quot; /&gt;
console창 출력 설정 탭
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Clear&lt;/strong&gt;: 모든 로그 삭제, 미해결 로그는 제외&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Clear on Play&lt;/strong&gt;: 씬을 플레이하기 전까지의 로그 삭제&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Clear on Build&lt;/strong&gt;: 빌드 직전까지의 로그 삭제&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Collapes&lt;/strong&gt;: 같은 종류의 로그끼리 보기 쉽게 묶음&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Error Pause&lt;/strong&gt;: 플레이 도중 에러 발생시 씬 일시 정지&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. Editor&lt;/strong&gt;: 유니티 에디터 외부의 기기에서 로그를 받아옴&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;툴바와-씬-편집&quot;&gt;툴바와 씬 편집&lt;/h3&gt;

&lt;h4 id=&quot;1-툴바&quot;&gt;1) 툴바&lt;/h4&gt;

&lt;p&gt;유니티 에디터 창의 좌측 상단에 툴바 메뉴들이 있다&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;225&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147742860-042b81e4-4235-4d99-89fe-59b56d5de04f.png&quot; /&gt;
&lt;br /&gt;
툴바 메뉴
&lt;/p&gt;

&lt;p&gt;좌측부터&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Hand&lt;/strong&gt;: 씬 카메라 이동&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Translate&lt;/strong&gt;: 오브젝트 이동&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Rotate&lt;/strong&gt;: 오브젝트 회전&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Scale&lt;/strong&gt;: 오브젝트 크기 조정&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Rect&lt;/strong&gt;: UI 및 2D 오브젝트 크기 조정&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. Transform&lt;/strong&gt;: 평행이동, 회전, 스케일 툴을 하나로 합친 툴&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. Custom editor&lt;/strong&gt;: 복잡한 개인 맞춤 툴 사용 가능&lt;/p&gt;

&lt;p&gt;커스텀을 제외한 6개의 툴은 &lt;em&gt;qwerty&lt;/em&gt;로 단축키 사용 가능!&lt;/p&gt;

&lt;h4 id=&quot;2-씬-편집&quot;&gt;2) 씬 편집&lt;/h4&gt;

&lt;p&gt;-마우스 휠 스크롤로 줌아웃/줌인 가능&lt;/p&gt;

&lt;p&gt;-Hand 툴로 카메라 이동 가능&lt;br /&gt;
*마우스 휠버튼 클릭으로 바로 Hand 툴 사용 가능&lt;/p&gt;

&lt;p&gt;-Flythrough 모드: 씬 창에서 마우스 우클릭을 누르고 있으면 작동, WASD로 움직일 수 있음&lt;/p&gt;

&lt;p&gt;-Orbit 모드: 씬 창에서 Alt+마우스 좌클릭으로 작동, 씬 중심에 있는 물체를 기준으로 마우스 공전 가능&lt;/p&gt;

&lt;h4 id=&quot;3-오브젝트-편집&quot;&gt;3) 오브젝트 편집&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;-Translate(평행이동)&lt;/strong&gt;: Translate 툴로 오브젝트를 원하는 방향으로 이동 가능&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;735&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147748404-17aa6527-65ab-4254-9d75-a8b80cac6b61.png&quot; /&gt;
위 그림에서 가운데 빨간색, 파란색, 초록색을 눌러 X축, Z축, Y축을 고정하고 이동시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Rotate(회전)&lt;/strong&gt;: Rotate 툴로 오브젝트를 회전시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;736&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147748885-cb603342-ca13-4af8-9eea-f49003a4bba6.png&quot; /&gt;
위 그림에서 가운데 빨간색, 파란색, 초록색을 눌러 X축, Z축, Y축을 기준으로 회전시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Scale(크기)&lt;/strong&gt;: Scale 툴로 오브젝트의 크기 배율을 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;738&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147748561-941fbc42-af9d-4af5-b04d-61aa0247f261.png&quot; /&gt;
위 그림에서 가운데 빨간색, 파란색, 초록색을 눌러 X축, Z축, Y축을 고정하고 방향으로 크기를 변형할 수 있다. 가운데 회색 큐브를 클릭하면 세 축을 동시에 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Rect(직사각형)&lt;/strong&gt;: Rect 툴로 물체의 가로와 세로를 2D 직사각형으로 편집할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;733&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147748698-a6aef35c-4f7a-4176-96d7-27ee1e2fcec1.png&quot; /&gt;
Z축 방향을 무시하고 크기가 조정된다. UI나 2D오브젝트 편집에 주로 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Transform(변형)&lt;/strong&gt;: Transform 툴로 Translate, Rotate, Scale을 동시에 편집할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;735&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147748835-0d985fb5-fe5a-4600-af7e-300bab6285ff.png&quot; /&gt;
사용방법은 동일하다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;기즈모gizmo&quot;&gt;기즈모(Gizmo)&lt;/h3&gt;
&lt;p&gt;플레이어에겐 보이지 않고 개발자의 화면에서만 보이는 것들을 기즈모(Gizmo)라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;씬-기즈모scene-gizmo&quot;&gt;씬 기즈모(Scene gizmo)&lt;/h4&gt;
&lt;p&gt;씬의 좌측 상단에 있는 것을 ‘씬 기즈모’ 라고 한다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;150&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147749224-8d711514-8247-4bbd-a7ba-65e4ce853da5.png&quot; /&gt;
&lt;br /&gt;
씬 기즈모(Scene gizmo)
&lt;/p&gt;

&lt;p&gt;각 색깔의 원뿔 암(arm)을 클릭하면 각 축의 시점으로 변환할 수 있다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;가운데 투명 큐브를 클릭하면 ‘투영 전환’을 할 수 있다. 원근(Perspective) 모드와 등각(Isometric) 모드로 전환할 수 있다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;735&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147749461-6976842b-8cb6-4f7c-ac3b-3533b6277f3a.png&quot; /&gt;
&lt;br /&gt;
원근 모드
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;736&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147749400-6f36ca19-d1c7-4c21-bb80-be9928ac82ec.png&quot; /&gt;
&lt;br /&gt;
등각 모드
&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;씬-플레이-버튼&quot;&gt;씬 플레이 버튼&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;106&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/147749574-0f1b7f09-78e4-494f-a15b-04351c95d5bb.png&quot; /&gt;
&lt;br /&gt;
씬 플레이 버튼
&lt;/p&gt;

&lt;p&gt;왼쪽부터&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Play&lt;/strong&gt;: 현재 씬을 플레이하거나 종료&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Pause&lt;/strong&gt;: 현제 플레이중인 씬을 일시정지&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Step&lt;/strong&gt;: 한 프레임만큼 씬 플레이&lt;/p&gt;

&lt;h1 id=&quot;플레이-중-변경된-사항은-플레이-종료시-모두-삭제된다-반드시-플레이를-종료한-후-편집하자&quot;&gt;&lt;em&gt;플레이 중 변경된 사항은 플레이 종료시 모두 삭제된다. 반드시 플레이를 종료한 후 편집하자…!&lt;/em&gt;&lt;/h1&gt;</content><author><name>Kim Namsub</name></author><summary type="html">1. 유니티 인터페이스</summary></entry><entry><title type="html">First post</title><link href="http://localhost:4000/first-post/" rel="alternate" type="text/html" title="First post" /><published>2021-12-30T00:00:00+09:00</published><updated>2021-12-30T00:00:00+09:00</updated><id>http://localhost:4000/first%20post</id><content type="html" xml:base="http://localhost:4000/first-post/">&lt;p&gt;&lt;strong&gt;Hello&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It’s my first post&lt;/p&gt;

&lt;p&gt;-&lt;/p&gt;

&lt;p&gt;Here will be my footprints and what I did before&lt;/p&gt;

&lt;p&gt;Nice to meet you!&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">Hello</summary></entry></feed>