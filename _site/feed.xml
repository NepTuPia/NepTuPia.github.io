<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-28T23:49:49+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Footprints</title><subtitle>My milestones are here</subtitle><author><name>Kim Namsub</name></author><entry><title type="html">Unity programming(12)</title><link href="http://localhost:4000/Unity-Programming(12)/" rel="alternate" type="text/html" title="Unity programming(12)" /><published>2022-02-25T00:00:00+09:00</published><updated>2022-02-25T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(12)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(12)/">&lt;h1 id=&quot;벡터&quot;&gt;벡터&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;앞의 글에서 말한 대로 이번에는 책으로는 9장의 내용이다. 유니티에서 벡터에 대한 기본적인 개념과 수학적 개념들, 그리고 쿼터니언에 대해 배워보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 벡터의 절대 위치와 상대 위치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;벡터는 우리가 좌표상으로 인식하는 그 벡터를 의미한다. (0, 0)이라면 x, y좌표가 각각 0이라는 의미이다.&lt;/p&gt;

&lt;p&gt;다만 (1, 1)이라는 벡터를 예로 들면 이 벡터는 2가지의 의미를 가진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상대적인 방향과 크기&lt;br /&gt;벡터의 시작 좌표가 정해지지 않았을 때 그냥 (1, 1)의 벡터는 어디서부터 시작인지 알 수가 없다. 그저 방향과 크기만 벡터를 통해 알 수 있다.&lt;/li&gt;
  &lt;li&gt;절대적인 위치&lt;br /&gt; 벡터의 시작 좌표가 원점등으로 정해져있거나 알 수 있는 경우 (1, 1)이라는 벡터는 좌표계 상에서 절대적인 위치와 방향, 크기를 모두 알 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;2. 벡터의 크기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;우리가 아는 그 피타고라스 공식이다. (1, 1)의 벡터는 2제곱근의 크기를 지닌다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 스칼라 곱&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;벡터에 스칼라, 즉 어떤 상수를 곱할 수 있다. (1, 1)의 벡터에 3을 곱하면 (3, 3)이 되고 그 크기도 정확히 3배가 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 방향 벡터&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;공업수학에서 배운 그것, 크기가 1인 벡터이다. (3, -3)의 벡터가 있다면 벡터의 각 좌표를 크기로 나눠주면 크기가 1인 벡터로 만들 수 있다. 그리고 크기가 1인 벡터는 속력이 1이라고 표현할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 벡터의 덧셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;벡터의 덧셈은 같은 성분끼리 더해주면 된다. 좌표계상에서 살펴보면, A(1, 1) 벡터와 B(2, 3)벡터가 있다면 A + B = (1 + 2, 1 + 3) = (3, 4)이다. 이는 즉 A벡터만큼 이동한 후 B벡터만큼 이동한 후의 결과에 대한 값이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.벡터의 뺄셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;벡터의 뺄셈은 같은 성분끼리 뻴셈으로 구하며 두 벡터 사이에 한 벡터가 다른 벡터에 도달하기 위한 ‘거리와 방향’이다.&lt;/p&gt;

&lt;p&gt;예를들어 A(3, 0)벡터와 B(10, 0)벡터가 있다고 가정해보자. B - A = (10 - 3, 0 - 0) = (7, 0)이다. 이는 A벡터와 B벡터 사이의 간격이 7만큼이고 A벡터에서 B벡터로 가기 위해선 (7, 0)만큼의 방향과 크기로 가야 한다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;반대로 A - B = (3 - 10, 0 - 0) = (-7, 0)이다. 이는 B벡터에서 A벡터로 가기 위해선 (-7, 0)만큼의 방향과 크기로 가야 한다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 벡터의 내적&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;벡터의 내적은 한 벡터에서 다른 벡터로의 ‘투영’이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wikidocs.net/images/page/22384/inner_product.png&quot; alt=&quot;vector product&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림을 보면 이해하기 쉬울 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 벡터의 내적이 왜 중요한가?&lt;/p&gt;

&lt;p&gt;두 벡터 사이의 각도가 커질수록 벡터 내적의 결과는 작아진다. 이를 활용하면 두 벡터 사이의 거리를 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;두 벡터 사이의 각도가 0이면, 즉 방향이 일치하면 내적의 값은 1이다. 각도가 90이면 0이 되고 180이면 -1이다. 이렇게 두 벡터 사이의 각도를 내적을 통해 알아낼 수 있다.&lt;/p&gt;

&lt;p&gt;이를 활용하면 게임 오브젝트사이의 거리, 예를들어 탱크 몸체와 포신 사이의 각도, 플레이어의 시선과 실제로 이동하는 방향 사이의 각도 등을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8. 벡터의 외적&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;벡터의 외적은 두 벡터를 모두 수직으로 통과하는 벡터를 구하는 연산이다.&lt;/p&gt;

&lt;p&gt;벡터의 내적은 연산 결과가 숫자이지만, 외적의 결과는 또다른 ‘벡터’이다. 연산식은 X를 쓰며 두 벡터 A와 B에 대해 외적 벡터 C는 A X B = C로 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;vector cross&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 벡터를 모두 수직으로 통과하는 벡터를 공간상에서 생각해보자. 서로의 기저벡터가 1이나 -1의 곱으로 같아질 수 없는 벡터(즉, 일직선상에 존재하는 벡터)가 아닌 두 벡터는 한 평면(Plane)을 결정할 수 있다. 즉 두 벡터의 외적의 결과 벡터는 한 평면에 대해 수직인 벡터이다.&lt;/p&gt;

&lt;p&gt;이를 활용하면 “어떤 표면에 대해 수직인 방향”을 게임 내에서 구할 수 있다. 또한 A X B = C에서 순서를 바꾸면 B X A = -C가 된다. A와 B가 만들어내는 평면, 표면에 대해 해당 표면이 바라보는 방향, 즉 ‘평면의 방향’을 알 수 있다!&lt;/p&gt;

&lt;p&gt;이런 평면의 방향을 나타내는 벡터를 ‘노말벡터’라고 하며, 평면상의 두 벡터를 외적하여 구할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;유니티의-c-벡터&quot;&gt;유니티의 C# 벡터&lt;/h2&gt;

&lt;p&gt;유니티에서는 vector 종류 타입을 활용해 벡터를 사용할 수 있다. 앞서 다뤘던 vector3 타입 외에도 vector2, vector 4도 존재한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new vector2(x, y);
new vector3(x, y, z);
new vector4(x, y, z, w);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위처럼 객체를 만들어 각 타입의 벡터 변수를 만들어 사용한다.&lt;/p&gt;

&lt;p&gt;다만 vector타입들은 클래스가 아니라 구조체(Struct)로 선언되어 있다. 그러므로 레퍼런스 타입처럼 작동하지 않고 기본타입들처럼 작동하므로 조심해서 사용하자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스칼라 곱&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 a = new Vector3(3, 6, 9);
a = a * 10;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드처럼 * 연산자를 통해 간단하게 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;벡터 덧셈과 뺄셈&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 a = new Vector3(3, 6, 9);
Vector3 b = a + a;
Vector3 c = b - a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;벡터끼리의 덧셈과 뺄셈도 +, -로 구할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;벡터의 정규화&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 a = new Vector3(3, 6, 9);
Vector3 b = a.normalized;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;normalized 메서드로 간단히 벡터를 정규화해 방향벡터를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;벡터의 크기&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 a = new Vector3(3, 6, 9);
Vector3 b = a.magnitude;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;magnitude 메서드로 벡터의 크기를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;벡터의 내적&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 a = new Vector3(3, 3, 3);
Vector3 b = new Vector3(1, 2 ,3);
float c = Vector3.Dot(a, b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Vector3.Dot() 메서드로 두 벡터의 내적을 구할 수 있다. 이때의 결과는 어떠한 수 이므로 기본 타입의 변수에 담아야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;벡터의 외적&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 a = new Vector3(3, 3, 3);
Vector3 b = new Vector3(1, 2 ,3);
Vector3 c = Vector3.Cross(a, b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Vector3.Cross() 메서드로 두 벡터의 외적 벡터를 구할 수 있다. 이떄의 결과는 벡터이므로 Vector 종류의 타입에 담아야 한다.&lt;/p&gt;

&lt;h1 id=&quot;벡터-활용&quot;&gt;벡터 활용&lt;/h1&gt;

&lt;p&gt;배운 활용법을 사용해보자. currentPos와 destPos 2개의 벡터 변수가 있다고 가정하자. currentPos는 플레이어의 현재 위치를 나태나고 destPos는 플레이어가 가고자 하는 목표 위치를 나타낸다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 currentPos = new Vector3(1, 0, 1);
Vector3 destPos = new Vector3(5, 3, 5);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그렇다면 플레이어가 현재 위치에서 목적지까지의 벡터는 destPos - currentPos로 나타낼 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 플레이어가 가야하는 벡터의 크기(즉 플레이어와 목적지 사이의 거리)와 방향벡터는 아래처럼 간단히 구할 수 있다!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 currentPos = new Vector3(1, 0, 1);
Vector3 destPos = new Vector3(5, 3, 5);

Vector3 move = destPos - currentPos;

float distance = move.magnitude;
Vector3 direction = move.normalize;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;혹은 거리를 구할 때에는 내장된 메서드인 distance를 활용해&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 currentPos = new Vector3(1, 0, 1);
Vector3 destPos = new Vector3(5, 3, 5);

float distance = Vector3.Distance(currentPos, destPos);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로 구할수도 있다.&lt;/p&gt;

&lt;p&gt;목적지를 향한 방향벡터를 구했으므로 다음처럼 특정 거리만큼 이동한 후의 위치를 스칼라곱을 통해 구할 수도 있다!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 currentPos = new Vector3(1, 0, 1);
Vector3 destPos = new Vector3(5, 3, 5);

Vector3 move = destPos - currentPos;

float size = move.magnitude;
Vector3 direction = move.normalize;

//목적지를 향해 10만큼 이동
currentPos = currentPos + direction * 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;플레이어의 위치인 currentPos 벡터에서 목적지를 향해 ‘10’만큼 이동한 벡터를 구하는 과정이다.&lt;/p&gt;

&lt;h1 id=&quot;쿼터니언&quot;&gt;쿼터니언&lt;/h1&gt;

&lt;p&gt;Transform 컴포넌트는 3개의 멤버 변수로 구성되어 있다. position, localScale, rotation이다. 이중 position과 localScale은 Vector3 타입이지만 rotation은 quaternion(쿼터니언) 타입이다. 그러므로 아래와 같은 코드는 에러를 뱉는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;transform.position = new Vector3(0, 0, 10);
transform.localScale = new Vector3(1, 5, 10);

// roation은 Vector3타입이 아니므로 에러 발생
transform.rotation = new Vector3(1, 5, 3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;쿼터니언은 x, y, z외에도 w값을 가진다. 하지만 분명히 Transfrom 컴포넌트의 Inspector창에서 rotation 멤버 변수는 x, y, z 3개의 값만 입력받는다.&lt;/p&gt;

&lt;p&gt;쿼터니언을 제대로 이해할려면 어려운 수학적 내용을 이해해야 한다. 간단히 설명해보자. 3D물체의 회전을 3D 벡터를 활용해 표현하는 것을 ‘오일러각’이라고 한다. 하지만 회전시 두개의 축이 겹치게 되어 더이상 온전히 회전을 표현할 수 없게 되는 ‘짐벌락’이라는 현상때문에 3개의 성분만으로 3D공간에서 물체의 회전을 표현할 수 없다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 유니티에서는 쿼터니언이라는 체제를 도입해 물체의 회전을 표현했지만, 개발자가 직접 다루도록 두기엔 너무 어렵고 에러의 위험도 커 직접 쿼터니언 방식에 접근하는것을 막고 x, y, z의 Vector3 타입으로 다룰 수 있도록 배려해 준 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;쿼터니언 활용&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 회전 데이터 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오일러각을 표현하는 Vector3 타입의 값에서 새로운 Quaternion 값을 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Quaternion rotation = Quaternion.Euler(new Vector3(0, 60, 0);&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;회전을 Vector3(오일러각)로 가져오기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quaternion 타입은 위의 생성과 반대로 저장된 회전값을 Vector3 타입의 오일러값으로 도로 뱉어낼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quaternion rotation = Quaternion.Euler(new Vector3(0, 60, 0);

Vector3 eulerRotation = rotation.eulerAngles;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;eulerAngles 메서드로 변환할 수 있다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현재 회전에서 ‘더’ 회전하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(30, 0, 0)만큼 회전한 상태에서 (0, 60, 0)만큼 더 회전한 상태를 표현해보자.&lt;/p&gt;

&lt;p&gt;중요한 점은 (30, 0, 0)을 회전한 상태에서 (0, 60, 0)을 추가로 회전하는 것과 (30, 60, 0)을 한번 회전하는 것은 전혀 다른 회전이라는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quaternion a = Quaternion.Euler(30, 0, 0);
Quaternion b = Quaternion.Euler(0, 60, 0);

Quaternion rotation = a * b;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;쿼터니언에서 a에서 b만큼의 추가 회전은 +가 아니라 *를 통해 나타낸다. 쿼터니언 연산에는 행렬이 사용되기 때문이다.&lt;/p&gt;

&lt;p&gt;쿼터니언에 대한 더 많은 사용과 이해는 다음장에서 다룰 것이다.&lt;/p&gt;

&lt;p&gt;짐벌락과 쿼터니언의 이론에 대해선 기회가 되거나 필요가 느껴지면 공부해서 올려보겠다…!&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">벡터</summary></entry><entry><title type="html">Unity programming(11)</title><link href="http://localhost:4000/Unity-Programming(11)/" rel="alternate" type="text/html" title="Unity programming(11)" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(11)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(11)/">&lt;h1 id=&quot;9장-10장을-들어가기-전&quot;&gt;9장, 10장을 들어가기 전…&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;게임 월드에서 모든 오브젝트는 위치와 회전을 가진다. 그리고 ‘공간’은 오브젝트들을 담는 틀이면서, 오브젝트를 배치할 때 사용하는 위치와 회전을 측정하는 기준을 제공한다.&lt;/p&gt;

&lt;p&gt;어떤 오브젝트의 위치와 회전을 측정하는 기준은 상황에 따라 다르게 적용된다. ‘절대적인 원점’에서의 위치와 회전일 수도 있고 오브젝트끼리의 ‘상대적인’ 위치와 회전일 수도 있다.&lt;/p&gt;

&lt;p&gt;그리고 공간에서 이동하는 오브젝트는 속력과 방향, 즉 벡터를 가진다. 이 또한 절대적인 원점을 기준으로 정할 수도 있고 오브젝트와 비교해 정할 수도 있다.&lt;/p&gt;

&lt;p&gt;이렇듯 위치와 회전, 방향, 속력 등을 측정하는 기준은 상황에 따라 변하므로 어떤 기준을 제공하는 어떤 공간을 사용할지 결정해야 한다. 그리고 그것을 수학적으로 어떻게 코드로 표현할지도 배우고 고민해야 한다.&lt;/p&gt;

&lt;p&gt;9장과 10장에서는 이에 대한 내용을 배워 게임 월드 내에서 게임 오브젝트를 원하는 위치에 배치하고, 의도한 방향으로 움직이기 위해 방향, 위치, 회전, 속력, 움직임, 공간과 관련된 기초적인 수학 및 코딩 지식을 배울 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9장: 방향, 크기, 회전을 담당하는 벡터 수학과 쿼터니언&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;10장: 9장에서 배운 수학을 응용하여 유니티에서 움직임 표현 및 좌표계의 종류&lt;/strong&gt;&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">9장, 10장을 들어가기 전…</summary></entry><entry><title type="html">Unity programming(10)</title><link href="http://localhost:4000/Unity-Programming(10)/" rel="alternate" type="text/html" title="Unity programming(10)" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(10)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(10)/">&lt;h1 id=&quot;탄막-슈팅-게임닷지---최종-완성&quot;&gt;탄막 슈팅 게임’닷지’ - 최종 완성&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;앞서서 UI까지 제작을 완료했다. 이제 이 UI들과 게임을 전반적으로 관리할 게임매니저를 제작해보자.&lt;/p&gt;

&lt;h2 id=&quot;게임매니저-제작&quot;&gt;게임매니저 제작&lt;/h2&gt;

&lt;p&gt;게임의 규칙과 게임오버 상태, 생존 시간 등의 수치를 관리하고, 게임 UI를 갱신하는 게임 매니저(Game Manager)를 만들어보자. 닷지 게임에서 게임매니저는 다음과 같은 기능을 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;게임오버 상태 표현&lt;/li&gt;
  &lt;li&gt;생존 시간 갱신&lt;/li&gt;
  &lt;li&gt;UI를 갱신하고 표시&lt;/li&gt;
  &lt;li&gt;게임오버 시 게임 재시작&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;게임매니저 스크립트 준비&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;게0임 매니저 스크립트를 만들고 아래와 같이 작성하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; //UI 관련 라이브러리
using UnityEngine.SceneManagement; //씬 관련 라이브러리

public class GameManager : MonoBehaviour
{
    public GameObject gameoverText; //게임오버 시 활성화 할 텍스트 게임 오브젝트
    public Text timeText; //생존 시간을 표시할 텍스트 컴포넌트
    public Text recordText; //최고 기록을 표시할 텍스트 컴포넌트

    private float surviveTime; //생존 시간
    public bool isGameOver; //게임오버 상태

    void Start(){
        //생존시간과 게임오버 상태 초기화
        surviveTime = 0;
        isGameover = false;
    }

    void Update(){
        
    }

    //현재 게임을 게임오버 상태로 변경하는 메서드
    public void EndGame(){

    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;UI와 씬을 관리하기 위해 관련된 라이브러리들을 불러들어왔다.  그 외에 필요한 필드와 메서드를 작성했다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;필드 변수들&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;gameoverText는 자료형이 GameObject로, timeText와 recordText는 Text 자료형으로 선언되었다는 것을 주목하자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;우리는 유니티에서 어떤 게임 오브젝트의 컴포넌트를 해당 컴포넌트 타입의 변수를 선언함으로써 사용할 수 있었다.&lt;/strong&gt; recordText와 timeText는 실시간으로 내용이 변해야한다. 그러므로 Text 컴포넌트 타입으로 선언해서 Text 컴포넌트의 text에 접근해서 출력 내용을 변경할 수 있도록 한다. 이와 달리 GameverText는 그 내용은 변하지 않고 활성화할지 말지만 바뀌면 되므로 게임 오브젝트를 나타내는 타입인 gameObject로 선언한 것이다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;생존시간 측정 및 출력&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 생존시간을 측정해보자. Update() 메서드와 Time.deltaTime을 활용해 현재 얼마나 플레이어가 생존했는지 알 수 있다. 아래와 같이 Update() 메서드를 수정하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Update(){
    
    if(!isGameOver){
        surviveTime += Time.deltaTime;
        timeText.text = &quot;Time: &quot; + (int)surviveTime);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;게임오버 상태가 아니라면 시간을 계속 더해나가고, timeText 변수를 활용해 text 컴포넌트에 접근한 뒤 텍스트 내용을 현재 생존 시간을 표시하도록 수정해주자. Update() 메서드이므로 매 프레임마다 메서드가 실행되므로 자동으로 생존시간으 누적되고 화면에 표시될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;게임 재시작&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;게임을 재시작한다는 얘기는 현재 씬을 종료하고 새로운 씬을 실행한다는 의미이다. 유니티에서 씬은 하나의 게임 월드이므로 현재 씬을 해제하고 다른 씬을 새로 로드하면 다른 게임 월드로 전환되므로 새롭게 게임을 시작할 수 있다.&lt;/p&gt;

&lt;p&gt;아래와 같이 update() 메서드를 수정하자&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Update(){
    
    if(!isGameOver){
        surviveTime += Time.deltaTime;
        timeText.text = &quot;Time: &quot; + (int)surviveTime);
    }
    else{
        if(Input.GetKeyDown(KeyCode.R)){
            SceneManager.LoadScene(&quot;SampleScene&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Input.GetKeyDown() 메서드는 키 입력을 받을 때 까지 기다린다. 그러므로 유저가 재시작을 하기 전까지 대기할 수 있다. R을 입력하면 SceneManager가 실행된다.&lt;/p&gt;

&lt;p&gt;SceneManager은 SceneManagement 라이브러리에서 가저온 유니티에 내장된 씬 관리자이다. LoadScene() 메서드로 실행할 씬의 이름을 입력받아 해당 씬을 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EndGame() 메서드 구현&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 현재 게임을 게임오버 상태로 만드는 EndGame() 메서드를 구현하자. 이 메서드는 플레이어가 죽을 때 실행되며 현재 게임 상태를 게임오버 상태로 변경하고 게임오버 시 필요한 처리를 실행하는 메서드이다. 그러므로 다음과 같은 기능을 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;게임오버 상태은 isGameover을 true로 변경&lt;/li&gt;
  &lt;li&gt;현재 생존 시간 기록과 최고 생존 기록을 비교&lt;/li&gt;
  &lt;li&gt;게임오버 UI들을 활성화한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 만든 EndGame() 메서드는 플레이어의 스크립트에서 실행할 것이다. 그렇게하면 플레이어가 사망할 때 자동으로 EndGame() 메서드가 실행되게 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//현재 게임을 게임오버 상태로 변경하는 메서드
public void EndGame(){
    //게임 오버 상태를 true로 변경
    isGameOver = true;
    //게임오버UI 오브젝트를 SetActive()메서드로 활성상태로 변경
    gameoverText.SetActive(true);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;isGameOver 변수를 false에서 true로 변경해 게임오버 상태임을 나타내자. 그 후 아래 코드를 보자. gameoverText 변수는 타입으로 GameObject로 설정해 게임 오브젝트를 가리키도록 설정했다. 그러므로 SetActive() 메서드를 사용해 게임오버시 출력할 UI 오브젝트들을 활성상태로 변경한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최고기록 저장 및 불러오기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아직 EndGame() 메서드에서 해야 할 일이 남아있다. 최고기록을 관리하는 일이 필요하다.&lt;/p&gt;

&lt;p&gt;유니티에는 기본 내장 클래스로 &lt;strong&gt;PlayerPrefs&lt;/strong&gt;를 지원한다. 플레이어 설정이라는 클래스 명 그대로, 어떤 값들을 로컬에 저장하고 불러오는 것을 지원해 게임을 종료한 후에도 계속해서 어떤 정보를 저장할 수 있도록 해준다.&lt;/p&gt;

&lt;p&gt;저장에는 파이썬의 사전처럼 키와 값의 쌍으로 저장한다. SetFloat로 float 타입의 값을 저장할 수 있고 GetFloat로 다시 불러들어올 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PlayerPrefs.SetFloat(&quot;Gold&quot;, 50);

float gold = PlayerPrefs.GetFloat(&quot;Gold&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드는 “Gold”라는 키값으로 50을 로컬에 저장하고 gold라는 변수에 저장해둔 “Gold” 값을 불러들어오는 코드이다.&lt;/p&gt;

&lt;p&gt;주의할점은 int, string의 타입도 지원한다는 점이다. float로 저장해놓고 int로 불러들어오면 불러들어올 키가 존재하지 않으므로 기본값인 0이 반환되게 된다. PlayerPrefs를 활용해 나머지 EndGame() 메서드를 완성해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//현재 게임을 게임오버 상태로 변경하는 메서드
public void EndGame(){
    //게임 오버 상태를 true로 변경
    isGameOver = true;
    //게임오버UI 오브젝트를 SetActive()메서드로 활성상태로 변경
    gameoverText.SetActive(true);

    // BestTime을 키값으로 지금까지의 최고기록을 불러오기
    float bestTime = PlayerPrefs.GetFloat(&quot;BestTime&quot;);

    if(surviveTime &amp;gt; bestTime){
        //현재 생존기록이 최고기록보다 크다면 최고기록 갱신
        bestTime = surviveTime;
        //갱신하고 SetFloat()메서드를 활용해 로컬에도 저장
        PlayerPrefs.SetFloat(&quot;BestTime&quot;, surviveTime);
    }

    //현재까지의 최고기록을 출력
    recordText.text = &quot;Best Time: &quot; + (int)bestTime;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 PlayerPrefs.GetFloat(“BestTime”)으로 최고기록을 불러들인다. 아직 최고기록이 없다면 기본값인 0이 리턴되므로 걱정없다!&lt;/p&gt;

&lt;p&gt;그 후 생존기록이 최고기록보다 크다면 최고기록을 갱신하고 로컬에 저장까지 해주어 계속해서 최고기록이 유지될 수 있도록 코드를 작성했다.&lt;/p&gt;

&lt;p&gt;마지막으로 text 타입의 변수인 recordText를 활용해 최고기록을 출력하는 UI 오브젝트의 출력 내용을 현재 최고기록을 출력하도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;playerController 스크립트 수정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;플레이어가 죽을 때 EndGame() 메서드를 실행하도록 스크립트를 수정해주자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void Die(){
    //자신의 게임 오브젝트 비활성화
    gameObject.SetActive(false);

    //씬에 존재하는 GameManager 타입의 오브젝트를 찾아서 가져오기
    GameManager gameManager = FindObjectOfType&amp;lt;GameManager&amp;gt;();
    //가져온 GameManager 오브젝트의 EndGame() 메서드 실행
    gameManager.EndGame();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FindObjectOfType&amp;lt;&amp;gt;() 메서드는 제네릭으로 선언된 타입의 오브젝트를 씬에서 찾아 반환하는 메서드였다. 게임매니저는 스크립트 파일명이 GameManager였으므로 게임매니저의 타입은 GameManager이다.(클래스를 타입처럼 사용하는 것을 기억하자!) 그러므로 gameManager 변수에는 게임매니저가 할당되게 되고 EndGame() 메서드를 플레이어가 사망 시 자동으로 실행할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;게임매니저 오브젝트 설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이렇게 게임매니저를 위한 스크립트를 다 작성했으므로 게임매니저를 담당할 오브젝트를 만들고 스크립트를 컴포넌트로 넣어주자.&lt;/p&gt;

&lt;p&gt;Hierarchy창에서 빈 오브젝트를 만들고 Game Manager로 이름을 변경한 뒤 만들어둔 스크립트를 컴포넌트로 넣어주자.&lt;/p&gt;

&lt;p&gt;그리고 Inspector창에서 스크립트 내의 변수들이 지목할 오브젝트들을 설정해주자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/155504970-f89c043c-ae64-4777-ba60-17ac557860c4.png&quot; /&gt;
게임매니저 오브젝트 생성 및 스크립트 변수에 UI 오브젝트 할당
&lt;/p&gt;

&lt;p&gt;이제 각각의 텍스트들이 스크립트에서 작성한 대로 작동이 될 것이다!&lt;/p&gt;

&lt;p&gt;이렇게 우리의 첫 게임인 닷지가 최종적으로 완성되었다!&lt;/p&gt;

&lt;h2 id=&quot;빌드하기&quot;&gt;빌드하기&lt;/h2&gt;

&lt;p&gt;이제 만든 게임을 빌드해서 다른 사람에게 배포할 수 있도록 만들어보자.&lt;/p&gt;

&lt;p&gt;우선 빌드한 파일을 저장할 폴더를 아무대나 만들어두자.&lt;/p&gt;

&lt;p&gt;그 뒤에 File &amp;gt; Build Settings로 빌드 설정 창을 열자. 그리고 Build and Run을 누르면 파일 탐색기가 자동으로 띄어지고 아까 만들어둔 폴더를 선택한 뒤에 Save를 눌러 빌드를 진행하자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1334&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/155507691-9e297f52-736e-4bfc-a4d8-dc3679ac3569.png&quot; /&gt;
빌드완료 후 실행할 수 있는 app확장자의 파일이 생성
&lt;/p&gt;

&lt;h2 id=&quot;요약&quot;&gt;요약&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;프로젝트 창에서 폴더를 만들어 Assets를 정리할 수 있다.&lt;/li&gt;
  &lt;li&gt;transform.Rotate()로 게임 오브젝트를 회전시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;Update()메서드에서 단위 시간을 활용하려면 Time.deltaTime을 활용하자&lt;/li&gt;
  &lt;li&gt;모든 UI 오브젝트는 Canvas 오브젝트의 자식이 되어야 한다.&lt;/li&gt;
  &lt;li&gt;텍스트 컴포넌트가 출력하는 텍스트는 Text 타입의 변수를 통해 text 필드에 접근해서 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;PlayerPrefs 클래스와 내부 매서드를 활용해서 값을 로컬에 저장하고 불러올 수 있다.&lt;/li&gt;
  &lt;li&gt;PlayerPrefs는 키-값 방식으로 값을 저장하고 검색한다.&lt;/li&gt;
  &lt;li&gt;SceneManaer.LoadScene() 메서드로 씬 이름을 입력받아 해당 씬을 로드한다.&lt;/li&gt;
  &lt;li&gt;빌드 설청 창은 File &amp;gt; Build settings로 진입한다.&lt;/li&gt;
  &lt;li&gt;빌드 설정 창에서 Build 혹은 Build and Run으로 게임을 빌드해서 배포할 수 있다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Kim Namsub</name></author><summary type="html">탄막 슈팅 게임’닷지’ - 최종 완성</summary></entry><entry><title type="html">Unity programming(9)</title><link href="http://localhost:4000/Unity-Programming(9)/" rel="alternate" type="text/html" title="Unity programming(9)" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(9)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(9)/">&lt;h1 id=&quot;탄막-슈팅-게임닷지---최종-완성&quot;&gt;탄막 슈팅 게임’닷지’ - 최종 완성&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;앞에서 게임의 구성요소들을 완성했다. 이제는 UI를 만들고, 게임의 규칙을 관리하고 게임오버 상태를 표현하는 게임 매니저를 만들 것이다. 그리고 남은 게임 요소를 완성하고 게임을 빌드하여 닷지를 최종 완성해보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;게임 매니저와 UI 제작&lt;/li&gt;
  &lt;li&gt;씬 관리자로 씬을 로드하는 방법&lt;/li&gt;
  &lt;li&gt;PlayersPrefs를 사용해 데이터를 저장하는 방법&lt;/li&gt;
  &lt;li&gt;게임을 빌드하는 방법&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 내용들을 다룰 것이다.&lt;/p&gt;

&lt;h2 id=&quot;프로젝트-정리&quot;&gt;프로젝트 정리&lt;/h2&gt;

&lt;p&gt;현제 Asset들이 아무렇게나 위치해 있다. 이를 각각의 종류에 맞게 분류하는 작업을 해보자. 에셋들이 위치한 폴더를 바꾸고 분류한다고해서 게임과 씬에 영향을 미치지 않는다. 마음 편히 정돈하여 게임을 제작해 나가자!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;875&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/155346825-0af4fc19-d768-4026-9636-1484b83553e9.png&quot; /&gt;
종류별로 개별 폴더에 정리된 에셋들
&lt;/p&gt;

&lt;p&gt;위의 그림처럼 폴더를 생성하고 에셋들을 종류에 맞게 정리해주자. “Materials”, “Scripts”, “Prefabs” 3 종류의 폴더를 만들고 에셋들을 분류해줬다. 이렇게 작업해도 씬과 오브젝트, 게임에는 전혀 영향을 미치지 않으니 걱정하지 말자!&lt;/p&gt;

&lt;h2 id=&quot;바닥-회전&quot;&gt;바닥 회전&lt;/h2&gt;

&lt;p&gt;플레이어 아래의 바닥을 회전시켜 게임을 더 역동적이고 어렵게 만들 수 있다. 회전하는 스크립트를 작성한 뒤 바닥 오브젝트인 Level 오브젝트에 적용시켜보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ratator 스크립트 준비&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;게임 오브젝트를 일정 속도로 회전시키는 Rotator 스크립트를 준비하자&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Rotator : MonoBehaviour
{
    public float rotationSpeed = 60f;

    void Update()
    {
        transform.Rotate(0f, rotationSpeed, 0f);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Update() 메서드에 transform&lt;/p&gt;

&lt;p&gt;자 이렇게 코드를 작성하고 Level 오브젝트에 스크립트를 적용시켜보자. Level 하위에 있는 plane이 아니라 Level 자체에 스크립트를 컴포넌트로 넣어줘야한다. 그래야 Level의 하위 오브젝트들 전부가 회전한다!&lt;/p&gt;

&lt;p&gt;그러고 실행시켜보면 말도안되는 화면을 볼 수 있다. 코드상으로 보면 rotationSpeed를 60f로 줬으므로 초당 60도의 회전을 의도했지만 Update() 메서드는 매 프레임마다 실행되므로 60fps를 기준으로 3600도를 1초에 회전하게 된다.&lt;/p&gt;

&lt;p&gt;이처럼 단순 값을 파라미터로 주게 되면 컴퓨터의 성능, 즉 fps에 따라 프로그램이 다르게 작동하게 된다. 만약 1초에 60도를 돌아가게 코드를 작성했다면 유저가 fps를 2배 높이면 2배 더 빠르게 움직이거나 회전하게 되어 버그성 플레이가 가능하게 된다.&lt;/p&gt;

&lt;p&gt;이를 위해서 우리는 앞서 Time.deltaTime() 메서드를 사용했다. 이 메서드는 현제 컴퓨터의 프레임과 프레임 사이의 시간 간격을 리턴한다. 이를 이용하면 fps가 변하더라도 동일하게 작동하도록 코드를 작동할 수 있다.&lt;/p&gt;

&lt;p&gt;예를들어 60fps라면 update() 메서드의 실행 주기는 1/60초이지만 120fps가 되면 실행 주기는 1/120초로 바뀐다. 만약에 회전 코드를&lt;/p&gt;

&lt;p&gt;`
transform(0f, 1/60f, 0f)
`&lt;/p&gt;

&lt;p&gt;로 작성하게 되면 60fps에서만 의도한대로 작동한다. 이럴때 Time.deltaTime()을 사용하면 어떤 프레임에서도 알맞게 사용할 수 있다. 이를 활용해 스크립트를 수정해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Rotator : MonoBehaviour
{
    public float rotationSpeed = 60f;

    void Update()
    {
        transform.Rotate(0f, rotationSpeed * Time.deltaTime, 0f);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Time.deltaTime은 프레임사이의 시간 간격을 반환한다. 현제 120fps라면 1/120을 반환하므로 update() 메서드 실행마다, 즉 매 프레임마다 60 * 1 / 200 = 0.5도 만큼 회전하게 되어 1초에 60도를 회전하는 코드가 된다. 어떤 프레임에서도 1초에 60도만큼 회전시킬 수 있는 것이다!&lt;/p&gt;

&lt;h2 id=&quot;게임-ui-제작&quot;&gt;게임 UI 제작&lt;/h2&gt;

&lt;p&gt;이제 생존 시간, 게임오버, 최고 기록등을 표현할 수 있는 UI 제작법을 배워보자.&lt;/p&gt;

&lt;p&gt;다른 게임제작 툴들은 UI를 게임의 오브젝트들과는 별개로 취급해 만들어야한다. 하지만 유니티에서는 UI들도 게임 내의 오브젝트로 취급하기 때문에 오브젝트를 만들고 다루듯이 사용할 수 있다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;생존시간 텍스트 제작&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;총알을 피해 얼마나 살아남았는지 표시하는 UI를 만들자. 편집하기 쉽도록 2D로 화면을 바꾸고 편집해보자.&lt;/p&gt;

&lt;p&gt;씬창에서 “2D”를 클릭하면 2D 모드로 바꿀 수 있다. 그 다음 Hierarchy &amp;gt; Create(+버튼) &amp;gt; UI &amp;gt; Text로 생성하자. 그렇다면 자동으로 Canvas 탭이 포커스되며 Text 오브젝트가 생성될 것이다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1172&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/155485390-f9e78309-0a3a-413e-be1a-71d19a4e3553.png&quot; /&gt;
텍스트 UI 오브젝트 생성
&lt;/p&gt;

&lt;p&gt;텍스트 UI를 생성하니 3개의 오브젝트가 생성됬다. “Canvas”, “Text”, “EventSystem” 오브젝트가 생성되었다.&lt;/p&gt;

&lt;p&gt;UI 오브젝트들은 다른 게임 오브젝트들이 Transform 컴포넌트를 가지고 있듯이 Rect Transform 컴포넌트를 가지고 있다. 이 컴포넌트를 통해 위치를 조정할 수 있다.&lt;/p&gt;

&lt;p&gt;모든 UI 오브젝트들은 Canvas 오브젝트의 자식 오브젝트로 소속되어야한다. 즉 UI가 표시될 2차원 평면의 Canvas위에 UI들이 표시되도록 작동한다는 의미이다. Canvas 오브젝트는 일종의 액자고, UI들은 그 액자 안에 들어갈 그림인 것이다!&lt;/p&gt;

&lt;p&gt;EventSystem 오브젝트는 유저와 UI간의 상호작용을 담당한다. 클릭, 드래그 등의 이벤트가 발생하면 해당 UI 오브젝트에 이벤트 메시지를 보내 유저와 상호작용할 수 있는 역할을 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;텍스트 배치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;UI 오브젝트들은 앵커프리셋을 이용해 정렬한다. 사용해서 생성한 텍스트 UI 오브젝트를 배치해보자.&lt;/p&gt;

&lt;p&gt;UI 오브젝트 배치에는 앵커(Anchor), 피벗(Pivot), 포지션(Position) 3개의 값을 조정해 UI 오브젝트를 배치할 수 있다. 앵커프리셋은 UI의 배치를 편리하게 해주는 도구 모음집이며 편리하게 주요 위치로 오브젝트를 바로 배치할 수 있다. Alt키를 눌러 스내핑(Snapping)을 활성화 해서 텍스트 오브젝트를 상단 중앙으로 이동시켜보자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1340&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/155489218-dad98ea4-fd14-4dd3-99b4-724dcc0ec18b.png&quot; /&gt;
앵커 프리셋을 활용해 텍스트 UI 배치
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;텍스트 꾸미기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;생성한 텍스트 오브젝트의 Text 컴포넌트에서 텍스트 내용과 글 정렬을 바꿔주자. 내용을 “Time: 0”으로 바꾸고 Alignment를 이용해 텍스트를 가운데 정렬해주자. 색깔도 (255, 255, 255)로 흰색으로 변경해주자.&lt;/p&gt;

&lt;p&gt;그 후 Rect Transform 컴포넌트에서 Pos Y 값을 -30으로 조정해서 위치를 조금 내려주고 Text 컴포넌트에서 폰트사이즈를 키워주자. 그리고 Horizontal Overflow와 Vertical Overflow 항목도 Overflow로 변경해주자. 해당 옵션들은 텍스트 상자에 글자가 넘칠 때 어떻게 할지를 결정한다.&lt;/p&gt;

&lt;p&gt;Horizontal Overflow는 수평방향의 텍스트 처리를 담당한다.  Wrap으로 바꾸면 글자가 넘어가면 줄바꿈이 일어나고, Overflow로 설정하면 글자가 텍스트 상자를 넘어서도 그대로 출력된다.&lt;/p&gt;

&lt;p&gt;Vertical Overflow는 수직방향의 텍스트 처리를 담당한다. Truncate로 설정하면 글자가 넘어가면 자르고, Overflow 옵션은 넘어가는 글자를 그대로 출력한다.&lt;/p&gt;

&lt;p&gt;마지막으로 입체효과를 주자. Time Text 오브젝트에 컴포넌트를 추가하자. Add Component &amp;gt; UI &amp;gt; Effect &amp;gt; Shadow로 그림자 컴포넌트를 추가해주자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1357&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/155491350-9cb68a6c-9f9c-427a-ad83-11f2436f24b9.png&quot; /&gt;
경과 시간 텍스트 설정 완료
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최고 기록 텍스트와 게임오버 텍스트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;앞서 만들었던 Time Text 오브젝트를 재활용하자. 복제한 뒤 이름을 “Gameover Text”로 변경하고 “Press R to restart”를 텍스트 내용으로 설정한 뒤 앵커프리셋을 활용해 한가운데에 배치해주자.&lt;/p&gt;

&lt;p&gt;최고 기록 텍스트는 게임오버 텍스트를 복제한 뒤 게임오버 텍스트보다 아래에 위치하도록 설정해주고 글씨 크기를 줄인 뒤 생성해주자. 중요한 점은 최고 기록 텍스트 오브젝트는 게임오버 텍스트와 동시에 나타나야 하기에 Gameover Text 오브젝트의 자식 오브젝트로 만들어줘야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;마지막으로, 게임오버텍스트와 최고기록 텍스트는 평소에는 보이지 않아야 한다. 그러므로 Inspector창에서 비활성화해주어 평소 화면에는 보이지 않도록 해주자. UI 오브젝트들의 세세한 작동은 스크립트 파일로 작동시킬 것이다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1677&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/155492518-274ddba2-a141-4228-ac52-7dc247bdbd90.png&quot; /&gt;
게임오버와 최고기록 텍스트 생성 및 비활성화
&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">탄막 슈팅 게임’닷지’ - 최종 완성</summary></entry><entry><title type="html">Unity programming(8)</title><link href="http://localhost:4000/Unity-Programming(8)/" rel="alternate" type="text/html" title="Unity programming(8)" /><published>2022-02-16T00:00:00+09:00</published><updated>2022-02-16T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(8)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(8)/">&lt;h1 id=&quot;탄막-슈팅-게임-닷지---탄알-제작&quot;&gt;탄막 슈팅 게임 ‘닷지’ - 탄알 제작&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;탄알-생성기-준비&quot;&gt;탄알 생성기 준비&lt;/h1&gt;

&lt;p&gt;탄알 오브젝트가 준비되었으므로 탄알 생성기를 만들어보자. 탄알 생성기 게임 오브젝트는 랜덤한 시간 간격으로 탕알을 생성해 플레이어를 향해 발사한다. 탄알 생성기의 기능은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;붉은 원기둥 모양&lt;/li&gt;
  &lt;li&gt;랜덤한 시간 간격으로 탄알 생성&lt;/li&gt;
  &lt;li&gt;Bullet 프리팹을 원본으로 탄알을 생성&lt;/li&gt;
  &lt;li&gt;플레이어를 향하도록 탄알을 생성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;원기둥(Cylinder) 오브젝트 생성 및 색깔 설정은 건너뛰겠다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1284&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154257510-820044ba-5975-47ef-ac63-480b6722d585.png&quot; /&gt;
원기둥 오브젝트 생성 및 머티리얼 설정 - Bullet Spawner
&lt;/p&gt;

&lt;p&gt;이제 탄알 생성기를 위한 스크립트를 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;탄알 생성기 스크립트 만들기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;탄알 생성기는 기능을 하기 위해 다음과 같은 변수들이 필요하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;생성할 탄알의 원본 - 프리팹&lt;/li&gt;
  &lt;li&gt;탄알을 발사하여 맞출 대상&lt;/li&gt;
  &lt;li&gt;탄알을 생성하는 시간 간격&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BulletSpawner : MonoBehaviour{
    public GameObject bulletPrefab; //생성할 탄알의 원본 프리팹
    public float spawnRateMin = 0.5f; //최소 생성 주기
    public float spawnRateMax = 3f; //최대 생성 주기

    private Transform target; //발사할 대상
    private float spawnRate; //생성 주기
    private float timeAfterSpawn; //최근 생성 시점에서 지난 시간

    void Start(){
        
    }

    void Update(){
        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 변수들을 선언하고 스크립트를 만들 준비를 해두자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Start() 메서드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Start() 메서드는 발사를 위한 준비를 해야 한다. 그러므로 시간에 대한 초기화와 발사 목표인 플레이어 오브젝트를 불러와야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Start(){
    //최근 생성 이후의 누적 시간을 0으로 초기화
    timeAfterSpawn = 0f;
    //탄알 생성 간격을 spawnRateMin과 spawnRateMax 사이에서 랜덤 지정
    spawnRate = Random.Range(spawnRateMin, spawnRateMax);
    //PlayerController 컴포넌트를 가진 게임 오브젝트를 찾아 조준 대상으로 지정
    target = FindObjectOfType&amp;lt;PlayerController&amp;gt;().transform;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막 코드를 잘 살펴보자. FindObjectOfType&amp;lt;&amp;gt;() 메서드는 &amp;lt;&amp;gt;안에 명시된 타입의 오브젝트를 찾아 접근하는 메서드다. 플레이어는 PlayerController라는 이름이 스크립트를 컴포넌트로 가지고 있다. 스크립트명은 클래스명과 같으므로 즉 타입 이름과 같다. PlayerController라는 컴포넌트(타입)을 지닌 오브젝트에 접근해 해당 오브젝트의 transform 값을 가져와 transform 타입의 target 변수에 대입해 탄알을 조준할 수 있도록 하는 것이다.&lt;/p&gt;

&lt;p&gt;다만 FindObjectOfType&amp;lt;&amp;gt;() 메서드는 씬 내의 모든 오브젝트를 탐사하기에 비용이 큰 메서드이다. 그러므로 Start() 같은 한두번 실행되는 메서드 내에서 사용해야한다. Update() 같은 메서드 내에서 사용하면 심각하게 느려질 수도 있다.&lt;/p&gt;

&lt;p&gt;FindObjectsOfType&amp;lt;&amp;gt;() 메서드도 있다. Objects라는 메서드명에서 알 수 있듯이 모든 오브젝트를 찾아 배열로 반환한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일정 주기로 실행 반복하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Update() 메서드를 활용해 탄알을 생성할 것이다. 그러나 그대로 사용하면 1초에 수십개의 탄알이 발사되므로 난이도가 너무 어려워진다. 이를 해결하기 위해 마지막으로 탄알이 생성된 시간을 체크하는 timeSpawnRate 변수를 활용한다.&lt;/p&gt;

&lt;p&gt;timeAfterSpawn 값은 시간의 흐름에 맞춰 증가한다. 주기적으로 현재 timeAfterSpawn 변수값을 체크해서 탄알 생성 주기보다 커진 순간 탄알을 생성하고 timeAfterSpawn을 0으로 리셋한다. 이를 반복하면 일정 주기로 총알을 발사할 수 있다. 이때 필요한것이 Update() 메서드의 실행 시간 간격이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update() 메서드의 실행 시간 간격&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Update() 메서드는 앞에서 배웠던대로 화면의 갱신 시 마다 실행된다. 따라서 직전 Update()의 실행과 현재 Update()의 실행 사이의 시간 간격이 한 프레임을 그리는데에 소요되는 시간이다.&lt;/p&gt;

&lt;p&gt;Time.deltaTime 메서드를 사용하면 프레임 사이의 시간 간격이 자동으로 할당되어 사용할 수 있다. 60FPS의 컴퓨터에서는 1/60이 되고 120FPS의 컴퓨터에서는 1/120이 된다. 그러므로 Update() 메서드에서 변수에 Time.deltaTime을 누적해서 더해가면 시간을 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Instantiate() 메서드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;탄알을 복제하는데 Instantiate() 메서드를 사용할 것이다. 유니티에서 게임 플레이중 실시간으로 오브젝트를 생성하는데에 사용하는 메서드이다.&lt;/p&gt;

&lt;p&gt;`
Instantiate(원본, 위치, 회전);
`&lt;/p&gt;

&lt;p&gt;위의 코드처럼 원본을 파라미터로 넣으면 해당 원본을 본딴 오브젝트를 생성한다. 즉, 클래스에서 객체를 찍어내는 것이다! (인스턴스화). ‘위치’와 ‘회전’ 파라미터도 넣어서 실행하면 생성할 위치와 회전 정도도 지정할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 위의 내용을 바탕으로 Update() 메서드를 완성해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Update(){
    //timeAfterSpawn 갱신
    timeAfterSpawn += Time.deltaTime;

    //최근 생성 시점에서부터 누적된 시간이 생성 주기보다 크거나 같다면 실행
    if (timeAfterSpawn &amp;gt;= spawnRate){
        //누적된 시간 리셋
        timeAfterSpawn = 0;

        //총알 생성, 만들어둔 탄알 프리팹을 원본으로 쓰고 탄알생성기 자신의 위치와 회전 정도를 동일하게 탄알에게 줌
        GameObject bullet = Instantiate(bulletPrefab, transform.position, transform.rotation);
        //생성된 bullet 게임 오브젝트의 정면 방향이 target(플레이어)를 향하도록 설정
        bullet.transform.LookAt(target);
        //다음 생성 간격을 랜덤하게 다시 설정
        spawnRate = Random.Range(spawnRateMin, spawnRateMax);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막에 쓰인 LootAt() 메서드는 해당 방향으로 오브젝트의 Rotation을 변경한다.&lt;/p&gt;

&lt;p&gt;제일 마지막에 생성 간격도 다시 랜덤하게 설정하기에 보다 더 불규칙적으로 탄알을 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;이를 이제 저장하고 bulletSpawner 오브젝트에 적용해보자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1678&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154274969-7ba7fd35-ec49-48b7-ac6b-b398ffeb4ff2.png&quot; /&gt;
완성된 탄알 생성기
&lt;/p&gt;

&lt;p&gt;bulletSpawner 오브젝트에 스크립트를 컴포넌트로 추가했다면 bullet Prefab에 할당될 오브젝트를 Asset의 Bullet 프리팹으로 설정해주기까지 완료하자. (상단 그림의 우측 하단)&lt;/p&gt;

&lt;h1 id=&quot;완성&quot;&gt;완성!&lt;/h1&gt;

&lt;p&gt;자 이제 총알생성기를 상하좌우 4개 모든곳에 설치해주자. 프리팹으로 만들어뒀으므로 간단하게 이미 만들어준 총알생성기를 복제해서 설치할 수 있다. Position 좌표만 수정해 적절한 위치에 두고 씬을 플레이해보자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1285&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154928386-acc7ddf8-3a89-42be-9dd8-73730366d10b.png&quot; /&gt;
완성!
&lt;/p&gt;

&lt;p&gt;넘모 재밌고? 근데 갸어려움&lt;/p&gt;

&lt;h1 id=&quot;요약&quot;&gt;요약&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;게임 오브젝트를 프리팹(Prefab)으로 만들어 재활용할 수 있다.&lt;/li&gt;
  &lt;li&gt;리지드바디 컴포넌트의 Use Gravity 필드를 해제하면 중력의 영향을 받지 않는다.&lt;/li&gt;
  &lt;li&gt;변수 transform은 스크립트에서 자신의 트랜스폼 컴포넌트로 바로 접근하는 지름길이다.&lt;/li&gt;
  &lt;li&gt;Destroy() 메서드는 주어진 오브젝트를 파괴하고 두번째 파라미터로 파괴 지연시간을 설정할 수 있다.&lt;/li&gt;
  &lt;li&gt;트리거 콜라이더는 충돌은 감지하되 상대방 콜라이더를 밀어내지 않는다.&lt;/li&gt;
  &lt;li&gt;OnTriggerEnter(), OnCollisionEnter() 메서드로 충돌을 감지할 수 있다.&lt;/li&gt;
  &lt;li&gt;OnCollisionEnter()은 일반 충돌 시 자동으로 실행된다.&lt;/li&gt;
  &lt;li&gt;OnCollisionStay(), OnCollisionExit()으로 각각 충돌하는 동안과 충돌을 마칠 때를 감지할 수 있다.&lt;/li&gt;
  &lt;li&gt;OnTriggerEnter()은 트리거 충돌시에 자동으로 실행된다.&lt;/li&gt;
  &lt;li&gt;OnTriggerStay(), OnTriggerExit()으로 각각 트리거로 충돌하는 동안과 충돌을 마칠 때를 감지할 수 있다.&lt;/li&gt;
  &lt;li&gt;충돌한 상대방 게임 오브젝트를 태그로 식별할 수 있다.(플레이어 오브젝트는 우리가 태그로 Player로 지정했었다!)&lt;/li&gt;
  &lt;li&gt;FindObjectOfType()은 씬에 있는 모든 오브젝트를 검색하여 원하는 타입의 오브젝트를 가져온다.&lt;/li&gt;
  &lt;li&gt;Instantiate() 메서드는 입력한 원본 오브젝트의 복제본을 생성한다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Kim Namsub</name></author><summary type="html">탄막 슈팅 게임 ‘닷지’ - 탄알 제작</summary></entry><entry><title type="html">Unity programming(7)</title><link href="http://localhost:4000/Unity-Programming(7)/" rel="alternate" type="text/html" title="Unity programming(7)" /><published>2022-02-16T00:00:00+09:00</published><updated>2022-02-16T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(7)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(7)/">&lt;h1 id=&quot;탄막-슈팅-게임-닷지---탄알-제작&quot;&gt;탄막 슈팅 게임 ‘닷지’ - 탄알 제작&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;앞에서 레벨과 플레이어 게임 오브젝트를 만들고 조작할 수 있도록 설정을 마쳤다. 이제 탄알 게임 오브젝트를 완성하고, 탄알 생성기로 탄알을 주기적으로 생성해 플레이어와 상호작용할 수 있도록 만들자&lt;/p&gt;

&lt;h2 id=&quot;탄알-게임-오브젝트-준비&quot;&gt;탄알 게임 오브젝트 준비&lt;/h2&gt;

&lt;p&gt;게임에서 탄알은 생성된 후 앞쪽으로 일정 속도로 날아가며, 어떤 게임 오브젝트와 충돌했을 때 그 오브젝트가 플레이어라면 파괴하는 기능을 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bullet 게임 오브젝트 생성&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;구(Sphere) 게임 오브젝트 생성(Hierarchy &amp;gt; Create &amp;gt; 3D object &amp;gt; Sphere)&lt;/li&gt;
  &lt;li&gt;오브젝트의 이름을 Bullet으로 변경&lt;/li&gt;
  &lt;li&gt;오브젝트의 위치를 (0, 5, 0), 스케일을 (0.5, 0.5, 0.5)로 변경&lt;/li&gt;
  &lt;li&gt;Hierarchy 창에서 Bullet 더블클릭 &amp;gt; Bullet 게임 오브젝트가 씬에서 포커스 됨&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Bullet의 머티리얼 설정&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상단 Assets &amp;gt; Create &amp;gt; Material&lt;/li&gt;
  &lt;li&gt;생성된 머티리얼의 이름을 Bullet Color로 설정&lt;/li&gt;
  &lt;li&gt;Inspector 창에서 Bullet Color 머티리얼의 Albedo의 색깔을 (255, 0, 0)으로 변경&lt;/li&gt;
  &lt;li&gt;설정을 완료한 머티리얼을 Bullet 오브젝트에 드래그&amp;amp;드랍으로 적용&lt;/li&gt;
&lt;/ol&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1284&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154226015-5860b393-41c9-4360-be1d-e6777504e0c9.png&quot; /&gt;
Bullet 오브젝트 생성 및 머티리얼 적용
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;리지드바디 컴포넌트 설정하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;탄알이 속도를 가지도록 Bullet 게임 오브젝트에 리지드바디 컴포넌트를 추가하자&lt;/p&gt;

&lt;p&gt;탄알은 중력의 영향을 받지 않고 앞으로만 나아가야하므로 리지드바디 컴포넌트의 ‘Use Gravity’를 체크 해제해 중력의 영향을 받지 않도록 설정하자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154226102-26b57de1-534c-42f1-a22c-1441c2a0c4d0.png&quot; /&gt;
리지드바디 컴포넌트 적용 및 무중력 설정
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;콜라이더 설정하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bullet 오브젝트는 Shpere 오브젝트이므로 구 콜라이더(Sphere Colider)가 추가되어 있어 물리적인 표면이 존재한다. 따라서 콜라이더를 지닌 다른 게임 오브젝트와 충돌하게 된다.&lt;/p&gt;

&lt;p&gt;이제 탄알이 다른 탄알과 충돌했을 경우에는 충돌이 일어나지 않도록 설정할 것이다, 이때 트리거(Trigger)로 설정된 콜라이더를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;트리거 콜라이더&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;트리거 콜라이더는 충돌을 감지하긴 하지만 실제로 접촉이 일어나는 물리적 표면은 지니고 있지 않다, 즉 충돌을 감지해 어떤 기능을 실행할지 말지 결정하는 방아쇠(Trigger)의 역할을 한다.&lt;/p&gt;

&lt;p&gt;예를들어 플레이어가 결승선에 통과했는지 아닌지를 판단하기 위해 트리거 콜라이더를 사용한다. 아니면 어떤 지역이나 구역에 들어서면 적을 스폰하기 위해서도 사용하는 등 굉장히 유용한 기능이다.&lt;/p&gt;

&lt;p&gt;Bullet 오브젝트의 Inspector 창 &amp;gt; Sphere Collider 컴포넌트의 ‘Is Trigger’ 박스에 체크하면 트리거 콜라이더로 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bullet을 프리팹으로 만들기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bullet 게임 오브젝트 구성이 완료되었으므로 탄알생성기를 만들어 탄알을 게임중 실시간으로 생성되게 만들 것이다.&lt;/p&gt;

&lt;p&gt;‘프리팹(Prefab)’은 언제든지 재사용할 수 있는 미리 만들어진 게임 오브젝트 asset이다. 비슷한 게임 오브젝트를 여러 개 만들 때 매번 다시 설정하는 번거로움을 줄이기 위해 프리팹을 사용한다.&lt;/p&gt;

&lt;p&gt;게임 오브젝트를 프리팹으로 만들어두면 나중에 간편하게 복제해 사용할 수 있다. 프리팹은 파일로 저장되기 때문에 현재 씬뿐만 아니라 얼마든지 다른 씬에서 재활용할 수 있다. (Asset 창에 C# 스크립트 파일도 표시되는것을 기억해보자!)&lt;/p&gt;

&lt;p&gt;특정 게임 오브젝트를 프리팹으로 만들려면 드래그&amp;amp;드랩으로 Hierarchy창에 있던 오브젝트를 Asset창으로 끌어오자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1278&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154228378-d9768bf6-fb73-4e34-87c0-4ffe6a99e3e4.png&quot; /&gt;
Bullet 오브젝트를 프리팹으로 설정
&lt;/p&gt;

&lt;p&gt;프리팹이 된 Bullet 오브젝트를 Hierarchy 창에서 보면 파란색으로 보이는 것을 확인할 수 있다. 프리팹으로 복제된 게임 오브젝트는 이처럼 파란색으로 표시된다.&lt;/p&gt;

&lt;h2 id=&quot;탄알-스크립트-준비&quot;&gt;탄알 스크립트 준비&lt;/h2&gt;

&lt;p&gt;이제 완성된 탄알 오브젝트가 제대로 작동하도록 스크립트를 완성해보자. C# 스크립트를 만들고 Bullet으로 이름을 변경해 준비하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Bullet : MonoBehaviour
{
    public float speed = 8f; //탄알 이동 속력
    private Rigidbody bulletRigidbody; //이동에 사용할 리지드바디 컴포넌트

    void start(){
        //게임 오브젝트에서 Rigidbody 컴포넌트를 찾아 bulletRigidbody에 할당
        bulletRigidbody = GetComponent&amp;lt;Rigidbody&amp;gt;();
        //탄알 리지드바디 컴포넌트의 속도 = 앞쪽방향 * 이동 속력으로 벡터값으로 설정
        bulletRigidbody.velocity = transform.forward * speed;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bulletRigidbody 변수에 GetComponent&amp;lt;&amp;gt;() 메서드로 리지드바디 컴포넌트를 찾아 할당한 뒤 velocity에 속도벡터를 대입해준다. Start() 메서드이므로 탄알이 생성되자마자 앞으로 일정속도로 나아가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;transform&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위의 코드에서 transform이 무엇인지를 알아야 한다. Transform타입의 변수인 transform은 오브젝트의 트랜스폼 컴포넌트로 바로 접근하는 변수이다.&lt;/p&gt;

&lt;p&gt;C# 스크립트로 편의상 GetComponent&amp;lt;&amp;gt;() 메서드로 찾지 않아도 바로 transform 변수로 접근해서 사용할 수 있다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154242733-50fe7ef9-80eb-4bd7-bdf6-865c8bf2224f.png&quot; /&gt;
transform 변수로 접근하는 오브젝트의 트랜스폼 컴포넌트
&lt;/p&gt;

&lt;p&gt;transform.forward는 오브젝트의 앞쪽 방향(Z축)을 나타내는 Vector3 타입의 변수로서 앞쪽 방향을 바로 구할 수 있다.&lt;/p&gt;

&lt;p&gt;즉 transform.forward * speed로 방향 * 속도의 벡터값을 구할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;탄알 자동 파괴하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;생성된 탄알이 맵 밖으로 빠져나간 후 계속 남아있다면 컴퓨터의 메모리에 어마어마한 부하가 생길것이다. 이를 해결하기 위해 생성된 후 일정시간이 지나면 파괴되도록 설정해야 한다.&lt;/p&gt;

&lt;p&gt;Bullet 스크립트의 Start() 메서드를 다음과 같이 수정하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void start(){
    //게임 오브젝트에서 Rigidbody 컴포넌트를 찾아 bulletRigidbody에 할당
    bulletRigidbody = GetComponent&amp;lt;Rigidbody&amp;gt;();
    //탄알 리지드바디 컴포넌트의 속도 = 앞쪽방향 * 이동 속력으로 벡터값으로 설정
    bulletRigidbody.velocity = transform.forward * speed;

    //3초 뒤 자신의 게임 오브젝트 파괴
    Destroy(gameObject, 3f);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Destroy() 메서드는 특정 오브젝트를 파괴하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;`
Destroy(Object obj, float t);
`&lt;/p&gt;

&lt;p&gt;위와같이 사용하며 첫번째 파라미터로 파괴할 오브젝트, 두번째 인자로 초 단위로 지연시간을 줄 수 있다. 지연시간 파라미터는 생략할 수 있고 생략하면 즉시 파괴한다.&lt;/p&gt;

&lt;h2 id=&quot;탄알의-충돌-처리&quot;&gt;탄알의 충돌 처리&lt;/h2&gt;

&lt;p&gt;이제 탄알과 플레이어가 충돌을 감지하는 기능을 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;충돌 이벤트 메서드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;유니티에서 콜라이더를 가진 게임 오브젝트 A, B가 충돌한다고 가정해보자. A, B는 자신이 충돌했는지를 스스로 파악할 수 없다. 대신 충돌하면 충돌했다는 충돌 메시지가 A, B에게 보내지게 되는데 이를 통해 자신이 다른 오브젝트와 충돌했다는 것을 파악할 수 있다.&lt;/p&gt;

&lt;p&gt;게임 오브젝트와 그 컴포넌트들은 충돌 종류에 따라 OnTriggerEnter 혹은 On collisionEnter 메시지를 받게 된다.&lt;/p&gt;

&lt;p&gt;Start() 메서드가 오브젝트가 생성되자 마자 실행되거나 Update() 메서드가 매 프레임마다 실행되는 이유가 해당 메서드의 이름이 Start, Update이기 때문인 것 처럼 충돌 시 실행할 메서드를 만드는 방법은 OnTriggerEnter, OnCollisionEnter 이름의 메서드를 만들면 된다.&lt;/p&gt;

&lt;p&gt;또한 충돌 메시지에 충돌한 대상의 정보도 함께 첨부된다. 그러므로 이 게임에선 탄알이 충돌한 물체가 다른 탄알인지 플레이언지 구분해 적절한 행동을 취할 수 있다.&lt;/p&gt;

&lt;p&gt;이처럼 충돌 메시지에 대응하는 메서드를 ‘충돌 이벤트 메서드’ 라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OnCollision 계열 : 일반 충돌&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;일반적인 콜라이더를 가진 두 게임 오브젝트가 충돌할 때 발생하는 충돌 이벤트 메서드로 충돌한 두 콜라이더는 통과되지 않고 서로를 밀어낸다. 종류는 3가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;OnCollisionEnter(Collision collision) : 충돌한 순간&lt;/li&gt;
  &lt;li&gt;OnColiisionStay(Collision collision) : 충돌하는 동안&lt;/li&gt;
  &lt;li&gt;OnCollisionExit(Collision collision) : 충돌했다가 분리되는 순간&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OnCollision 계열의 메서드가 실행될 때에는 충돌 관련 정보가 Collision 타입의 변수로 들어온다. Collision 타입은 충돌 정보를 담는 컨테이너이며 이를 통해 충돌한 대상 오브젝트, 충돌 지점, 충돌 표면의 방향등의 정보를 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OnTrigger 계열 : 트리거 충돌&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;충돌한 오브젝트 중 하나라도 트리거 콜라이더를 지닌 경우 자동으로 실행되는 메서드들이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;OnTriggerEnter(Collider other) :충돌한 순간&lt;/li&gt;
  &lt;li&gt;OnTriggerStay(Collider other) : 충돌하는 동안&lt;/li&gt;
  &lt;li&gt;OnTriggerExit(Collider other) : 충돌했다가 분리되는 순간&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;트리거 충돌은 서로를 그대로 통과하므로 충돌 지점, 충돌 표면의 방향등의 정보는 들어오지 않고 충돌한 상대방 오브젝트가 다이렉트로 들어온다.&lt;/p&gt;

&lt;p&gt;또 하나 주의할 점은 트리거 콜라이더가 아닌 일반 콜라이더를 지닌 오브젝트도 트리거 콜라이더인 오브젝트와 충돌하면 OnTrigger 계열의 메서드가 실행된다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;탄알에 충돌 감지 구현&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 스크립트에 충돌 감지 기능을 구현해보자. 탄알은 트리거 콜라이더였으므로 OnTrigger 계열의 메서드를 사용해야 하며 다음과 같은 기능을 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;충돌한 상대방 게임 오브젝트가 플레이어인지 체크&lt;/li&gt;
  &lt;li&gt;상대방 게임 오브젝트가 플레이어이면 해당 게임 오브젝트의 PlayerController 컴포넌트의 Die() 메서드 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void OnTriggerEnter(Collider other){
	//충돌한 상대방 오브젝트가 Player  태그를 가진 경우
	if(other.tag == &quot;Player&quot;){
	    //상대방 게임 오브젝트에서 PlayerController 컴포넌트 가져오기
	    PlayerController playerController = other.GetComponent&amp;lt;PlayerController&amp;gt;();
	
	    //상대방으로부터 PlayerController 컴포넌트를 가져오는 데 성공했다면
	    if(playerController != null){
	        playerController.Die();
	    }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이리하여 완성된 탄알 오브젝트의 스크립트 코드는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Bullet : MonoBehaviour
{
    public float speed = 8f; //탄알 이동 속력
    private Rigidbody bulletRigidbody; //이동에 사용할 리지드바디 컴포넌트

    void start(){
        //게임 오브젝트에서 Rigidbody 컴포넌트를 찾아 bulletRigidbody에 할당
        bulletRigidbody = GetComponent&amp;lt;Rigidbody&amp;gt;();
        //탄알 리지드바디 컴포넌트의 속도 = 앞쪽방향 * 이동 속력으로 벡터값으로 설정
        bulletRigidbody.velocity = transform.forward * speed;

        //3초 뒤 자신의 게임 오브젝트 파괴
        Destroy(gameObject, 3f);
    }

    void OnTriggerEnter(Collider other){
        //충돌한 상대방 오브젝트가 Player  태그를 가진 경우
        if(other.tag == &quot;Player&quot;){
            //상대방 게임 오브젝트에서 PlayerController 컴포넌트 가져오기
            PlayerController playerController = other.GetComponent&amp;lt;PlayerController&amp;gt;();

            //상대방으로부터 PlayerController 컴포넌트를 가져오는 데 성공했다면
            if(playerController != null){
                playerController.Die();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다 작성했으면 이제 Bullet 게임 오브젝트에 스크립트를 컴포넌트로 추가해야 한다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154250020-c40e7af7-c7e9-4f55-929b-35e3ca20321c.png&quot; /&gt;
스크립트를 컴포넌트로 추가 및 프리팹에 적용
&lt;/p&gt;

&lt;p&gt;드래그&amp;amp;드랍으로 스크립트를 Hierarchy 창에 있는 Bullet 오브젝트에 넣었다면 위의 그림처럼 Overrides &amp;gt; Apply All로 프리팹에 적용시켜주자.&lt;/p&gt;

&lt;p&gt;프리팹에 연동된 게임 오브젝트는 오브젝트의 변경사항을 위의 방법으로 프리팹 파일에 적용시킬 수 있다. 그 옆에 있는 Revert All을 하게 되면 모든 변경사항이 취소되고 다시 원래대로 돌아간다.&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">탄막 슈팅 게임 ‘닷지’ - 탄알 제작</summary></entry><entry><title type="html">Unity programming(6)</title><link href="http://localhost:4000/Unity-Programming(6)/" rel="alternate" type="text/html" title="Unity programming(6)" /><published>2022-02-12T00:00:00+09:00</published><updated>2022-02-12T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(6)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(6)/">&lt;h1 id=&quot;탄막-슈팅-게임-닷지---플레이어-제작2&quot;&gt;탄막 슈팅 게임 ‘닷지’ - 플레이어 제작(2)&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;플레이어-제작&quot;&gt;플레이어 제작&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;플레이어 사망 처리&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 플레이어 사망 처리를 할 Die() 메서드를 만들어보자.&lt;/p&gt;

&lt;p&gt;Die() 메서드는 자신의 게임 오브젝트를 비활정화하는 메서드이다. 이 메서드는 탄알과 플레이어가 충돌했을 때 실행될것이다.&lt;/p&gt;

&lt;p&gt;Die() 메서드는 PlayerController 스크립트가 스스로 실행하지 않는다. 플레이어에게 부딪힌 탄알이 Player Coltroller 스크립트에 접근하여 실행시킬것이며 그러므로 Die() 메서드는 public으로 접근제한자를 설정해 외부에서 접근 가능하도록 구현한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void Die(){
    //자신의 게임 오브젝트 비활성화
    gameObject.SetActive(false);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;gameObject는 MonoBehaviour 클래스에서 제공하는 게임 오브젝트 자기 자신을 가리키는 ‘변수’이다. 모든 컴포넌트는 gameObject 변수를 사용해 자신을 사용하고 있는 오브젝트(자신, 즉 컴포넌트의 게임 오브젝트)에 접근할 수 있다. PlayerColtroller 스크립트는 Player 오브젝트에 추가할 것이므로 gameObject 변수는 Player 오브젝트를 가리키게 되어 비활성화 처리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;GameObject와 gameObject를 혼동하면 안되는데, GameObject는 타입이고 gameObject는 변수이다. 즉,&lt;/p&gt;

&lt;p&gt;`
GameObject gameObject;
`&lt;/p&gt;

&lt;p&gt;인 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SetActive() 메서드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모든 게임 오브젝트는 스스로를 끄고 켜는 기능을 가지고 있다. 오브젝트의 Inspector 창에서 게임 오브젝트 이름 왼쪽에 보이는 체크 박스가 게임 오브젝트를 활성화/비활성화 하는 버튼이다.&lt;/p&gt;

&lt;p&gt;SetActive() 메서드는 GameObject 타입, 즉 클래스에 내장되어 있는 메서드로서 해당 게임 오브젝트의 활성/비활성화를 담당한다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153695310-fdb06492-b4e3-4f06-8457-2b1bf89b70a9.png&quot; /&gt;
활성/비활성화 하는 체크 박스
&lt;/p&gt;

&lt;p&gt;위의 체크박스는 SetActive() 메서드를 활용해 원격으로 이용할 수 있다. 위의 Die() 메서드는 체크박스를 해제해 비활성화 상태로 만든 것이며 SetActive(True)를 통해 다시 활성화시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PlayerController 컴포넌트 설정하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;완성한 PlayerController 스크립트를 Player 게임 오브젝트에 컴포넌트로 추가하고 실행해보자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153698454-7103f08f-3347-4a44-a2d5-6032e5f55acf.png&quot; /&gt;
스크립트 파일을 컴포넌트로 추가
&lt;/p&gt;

&lt;p&gt;위의 그림처럼 PlayerController 스크립트를 컴포넌트로 추가한 뒤 Player Rigid Body를 Player 오브젝트가 가지고 있던 리지드바디 컴포넌트로 할당해주자.&lt;/p&gt;

&lt;p&gt;이 상태에서 씬을 플레이하면 상하좌우에 맞춰 캡슐형태의 플레이어가 움직이는 것을 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;playercontroller-스크립트-개선하기&quot;&gt;PlayerController 스크립트 개선하기&lt;/h2&gt;

&lt;p&gt;이렇게 완성한 PlayerController 스크립트는 몇가지 문제점이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;조작이 게임에 즉시 반영되지 않는다. &lt;br /&gt; AddForce()로 힘을 주는 방식으로 움직임을 구현했기에 즉각적으로 움직이지 않고 가속도가 붙는 방식으로 움직이게 되어 조작감이 답답해진다.&lt;/li&gt;
  &lt;li&gt;입력 감지 코드가 복잡하다. &lt;br /&gt; 4개의 if문을 활용한 방식을 좀 더 간결하게 개선해야 할 필요가 있다.&lt;/li&gt;
  &lt;li&gt;playerRigidbody에 컴포넌트를 드래그&amp;amp;드롭으로 할당하는 것이 불편하다. &lt;br /&gt; 바로 앞에서 PlayerController 스크립트를 컴포넌트로 넣은 후 Player Rigid Body에 리지드바디 컴포넌트를 직접 손으로 할당했다. 이는 귀찮고 번거로우며 잘못된 컴포넌트를 할당할 위험도 있으므로 이를 코드로 처리할 필요가 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 문제점들을 하나씩 개선시켜 나가보자!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Start() 메서드 수정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3번 문제 해결을 위해 Start() 메서드를 활용해 게임이 시작될 때 playerRigidBody에 리지드바디 컴포넌트의 참조를 할당하도록 수정하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Rigidbody playerRigidBody; //이동에 사용할 리지드바디 컴포넌트

void Start()
{
    //게임 오브젝트에서 Rigidbody 컴포넌트를 찾아 playerRigidbody에 할당
    playerRigidBody = GetComponent&amp;lt;Rigidbody&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 playerRigidBody 변수의 접근제한자를 private로 접근해 외부에서 변경할 수 없도록 설정했다. 즉 Start() 메서드를 통해서만 변경 가능하도록 해 잘못된 컴포넌트를 할당할 위험을 제거했다.&lt;/p&gt;

&lt;p&gt;public이 아닌 변수는 Inspector창에서 확인할 수 없기때문에 이제 드래그&amp;amp;드롭 방식이나 드랍다운메뉴에서 선택하는 방식으로 컴포넌트를 할당할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;*GetComponent() 메서드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GetComponent() 메서드는 원하는 타입의 컴포넌트를 자신(스크립트)의 게임 오브젝트에서 찾아오는 메서드이다. 즉 자신(스크립트)를 컴포넌트로 가지고 있는 게임 오브젝트의 다른 컴포넌트를 찾아주는 메서드이다.&lt;/p&gt;

&lt;p&gt;GetComponent()가 해당하는 컴포넌트를 찾지 못하면 null값을 반환하며, &lt;Rigidbody&gt;는 제네릭을 사용해 GetConponent() 메서드가 다양한 타입의 컴포넌트에 작동할 수 있도록 한다.&lt;/Rigidbody&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;조작감 개선하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 1번째 문제였던 조작감 개선을 해보자. Update() 메서드를 수정해 이동속도 변화가 즉각 반영되도록 설정하자. 수정된 코드는 다음 기능들을 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;수평축과 수직축의 입력값을 감지&lt;/li&gt;
  &lt;li&gt;속도를 나타낼 새로운 Vector3 생성&lt;/li&gt;
  &lt;li&gt;리지드바디 컴포넌트의 속도 설정&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Update()
{
    //수평축과 수직축의 입력값을 감지하여 저장
    float xInput = Input.GetAxis(&quot;Horizontal&quot;);
    float zInput = Input.GetAxis(&quot;Vertical&quot;);
    
    //실제 이동 속도를 입력과 이동 속력을 사용해 결정
    float xSpeed = xInput * speed;
    float zSpeed = zInput * speed;

    //Vector3 속도를 (xSpeed, 0, zSpeed)로 설정
    Vector3 newVelocity = new Vector3(xSpeed, 0f, zSpeed);

    //리지드바디의 속도에 newVelocity 할당
    playerRigidbody.velocity = newVelocity;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Input.GetAxis() 메서드는 어떤 축에 대한 입력값을 숫자로 반환하는 메서드이다.&lt;/p&gt;

&lt;p&gt;`
Input.GetAxis(String axisName);
`&lt;/p&gt;

&lt;p&gt;코드에 쓰인 “Horizontal” 축과 “Vertical” 축에 매핑(Mapping)된 키의 입력이 감지되면 해당 입력이 축에 대해 양의 방향이면 1.0, 음의 방향이면 -1.0, 없으면 0.0을 반환하게 된다.&lt;/p&gt;

&lt;p&gt;이렇게 반환된 값에 speed = 8.0f를 곱해 현재의 속도를 구하고 이를 velocity3 타입의 값으로 설정해 플레이어 오브젝트의 현재 속도를 즉각적으로 변경한다.&lt;/p&gt;

&lt;p&gt;즉, Addforce() 메서드는 관성을 이용하는 메서드이다, 계속해서 힘을 가해 속도를 서서히 증가시키는 연속함수의 특징을 지닌다면 velocity 값을 변경하는 것은 이전 속도를 지우고 새로운 속도를 설정하는 구간함수의 특성을 지니는 것이다.&lt;/p&gt;

&lt;p&gt;이제 씬을 저장하고 게임을 플레이해보면 훨씬 개선된 조작감으로 플레이어 오브젝트를 조종할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;입력-매니저&quot;&gt;입력 매니저&lt;/h2&gt;

&lt;p&gt;Input.GetAxis() 메서드로 Input.GetKey() 메서드를 대체했었다. 이는 다음과 같은 의의가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;입력기 커스터마이제이션을 구현(흔히 말하는 컨트롤러 키 매핑-Mapping)&lt;/li&gt;
  &lt;li&gt;조이스틱같은 다양한 입력장치에 대응하기 위해&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;입력기 커스터마이제이션&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;처음에는 플레이어 컨트롤을 위해 update() 메서드에 다음과 같은 코드를 사용했다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (Input.GetKey(KeyCode.UpArrow == True){
	playerRigidbody.AddForce(0f, 0f, speed);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 이런 방식은 조작 키를 실시간으로 변경할 수 없다는 단점이 있다. 위의 예시는 방향키 위쪽인데 이를 w키로 바꿀려면 아래와 같이 변경해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (Input.GetKey(KeyCode.W == True){
	playerRigidbody.AddForce(0f, 0f, speed);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;조작키를 변경할 때 마다 코드를 수정해서 새로 빌드할 수 없으므로 우리는 다양한 키 커스터마이제이션을 위해 다른 방법을 강구해야 한다.&lt;/p&gt;

&lt;p&gt;즉,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ('특정 키'를 입력){
	수행;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;의 방식을&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (수행에 '해당하는 키'를 입력){
	수행;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;의 방식으로 바꿔야 한다. 이를 위해 위에서 사용한 ‘축’이 바로 이 방법이다. GetAxis()메서드에서 사용한 Horizontal과 Vertical도 이 ‘축’의 한 종류로 대응되는 버튼을 지닌다. 대응되는 버튼은 유니티의 입력매니저에서 설정할 수 있으므로 Horizontal 축을 변경할 대응 버튼을 위 아래 화살표에서 W, D로 입력매니저에서 변경만 해주면 코드 변경없이 사용할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;유니티 프로그램 상단 메뉴에서 Edit &amp;gt; Project Settings… &amp;gt; Input &amp;gt; Axes 리스트를 펼치면 입력축들에 대응되는 버튼들을 커스텀할 수 있다!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;953&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/154027974-1918ae15-b768-488f-b9ff-6ce87bc4c5a5.png&quot; /&gt;
여러 축에 대응되는 버튼 편집
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;멀티플랫폼 입력 지원&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위의 버튼 편집창에서 보면 ‘Horizontal’과 ‘Vertical’이 하단에 하나 더 있는 것을 확인할 수 있다. 아래는 XBOX 컨트롤러같은 게임패드와 연동되는 부분인데 이처럼 여러 플랫폼의 입력을 지원할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 여기에서 KeyCode.UpArrow처럼 true/false가 아닌 특정한 ‘값’으로 코드를 작성하는지에 대해 이유를 파악할 수 있다.&lt;/p&gt;

&lt;p&gt;키보드와 달리 컨트롤러는 조이스틱을 미는 정도를 조절할 수 있다. 끝까지 쭉 밀면 빠르게 이동하고 조금만 밀면 느리게 이동하는 캐릭터를 조종해본 경험이 있을 것이다. 이를 지원하기 위해 이같이 설정할 수 있도록 만든 것이다.&lt;/p&gt;

&lt;h2 id=&quot;요약&quot;&gt;요약&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;머티리얼(Mertirial)은 게임 오브젝트 표면의 색을 결정한다.&lt;/li&gt;
  &lt;li&gt;Main Camera 컴포넌트의 Clear Flags를 변경하여 게임 배경을 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;Update() 메서드는 매 프레임(게임 화면의 갱신 시)마다 실행된다.&lt;/li&gt;
  &lt;li&gt;gameObjec.~~~ 로 자신의 게임 오브젝트에 접근할 수 있는 변수로 MonoBehaviour에서 상속받은 변수이다.&lt;/li&gt;
  &lt;li&gt;GetComponent() 메서드는 게임 오브젝트로부터 원하는 타입의 컴포넌트를 찾아서 이용할 수 있게 해준다.&lt;/li&gt;
  &lt;li&gt;Vettor3 타입의 변수는 x, y, z값을 가지는 타입으로 위치, 스케일, 속도 등을 나타낼 수 있다.&lt;/li&gt;
  &lt;li&gt;리지드바디 컴포넌트에서 Constraints 필드에서 특정 축의 위치나 회전이 변경되지 않도록 고정할 수 있다.&lt;/li&gt;
  &lt;li&gt;리지드바디 컴포넌트는 현재 속도를 표현하는 변수인 velocity를 제공한다.&lt;/li&gt;
  &lt;li&gt;Input.GetKey() 메서드로 특정 키의 입력을 감지해 true/false로 반환한다.&lt;/li&gt;
  &lt;li&gt;Input.GetAxis() 메서드로 입력축에 대응되는 버튼의 입력을 감지할 수 있다.&lt;/li&gt;
  &lt;li&gt;Input.GetAxis() 메서드는 버튼 입력을 -1.0 ~ 1.0의 값으로 반환한다.&lt;/li&gt;
  &lt;li&gt;입력축(Axis)을 통해 코드 수정 없이 사용 버튼을 변경하고 멀티 플랫폼에 대응할 수 있다.&lt;/li&gt;
  &lt;li&gt;입력매니저에서 입력축을 관리한다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Kim Namsub</name></author><summary type="html">탄막 슈팅 게임 ‘닷지’ - 플레이어 제작(2)</summary></entry><entry><title type="html">Unity programming(5)</title><link href="http://localhost:4000/Unity-Programming(5)/" rel="alternate" type="text/html" title="Unity programming(5)" /><published>2022-02-09T00:00:00+09:00</published><updated>2022-02-09T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(5)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(5)/">&lt;h1 id=&quot;탄막-슈팅-게임-닷지---플레이어-제작&quot;&gt;탄막 슈팅 게임 ‘닷지’ - 플레이어 제작&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;레벨--및-카메라-설정&quot;&gt;레벨  및 카메라 설정&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 바닥 제작&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hierarchy &amp;gt; Create &amp;gt; 3D object &amp;gt; Plane으로 기본이 될 바닥을 만들자
Inspector창에서 Transform 컴포넌트의 Position에서 평면의 위치를 조정할 수 있다. 기본 원점인 (0, 0, 0)으로 셋팅해두자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;900&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153201009-628af2b9-cb66-498b-9ff4-5971b3eb274f.png&quot; /&gt;
평면 생성 및 원점에 셋팅
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 가로와 세로길이를 두 배 늘리기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Inspector 창의 Transform 컴포넌트의 스케일을 (2, 1, 2)로 변경&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153201165-b22e0e1b-6264-48a5-85a5-06e3d8641f5a.png&quot; /&gt;
Transform 컴포넌트와 셋팅값 조절
&lt;/p&gt;

&lt;p&gt;Unity에서 Plane의 가로 세로는 1당 10unit이다. 또한 1 Unit은 Cube 한번의 길이와 동일하다. 즉 1 길이의 Plane엔 10개의 Cube를 나열할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 1unit을 현실의 몇 m와 대응시킬지는 개발자 마음이나 보통 1unit = 1m로 셋팅한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 머티리얼(Material)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Unity에서 게임 오브젝트의 컬러는 머티리얼이 결정한다. 머티리얼은 셰이더 + 텍스처가 합쳐진 asset으로 오브젝트 픽셀의 컬러를 결정한다.&lt;/p&gt;

&lt;p&gt;Assets &amp;gt; Create &amp;gt; Material로 머티리얼 에셋을 만들자.&lt;/p&gt;

&lt;p&gt;이렇게 생선한 머티리얼의 Inspector창을 보자&lt;/p&gt;

&lt;p&gt;‘Albedo’는 반사율을 결정한다. 색상은 빛을 반사해서 우리눈에 들어오므로 Albedo가 결국 해당 게임 오브젝트의 색상을 결정하는 요소이다.&lt;/p&gt;

&lt;p&gt;생성한 머티리얼의 Albedo를 검정색으로 적용한 후  적용할 게임 오브젝트에 Drag &amp;amp; Drop으로 넣어 적용시켜보자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1166&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153202436-30dec31f-7ea3-4f45-bfc6-1fa1cc1e5e74.png&quot; /&gt;
머티리얼 제작 및 Plane에 적용
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 벽 제작&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 바닥 위에 벽을 만들어보자.&lt;/p&gt;

&lt;p&gt;Hierarchy &amp;gt; Create(+) &amp;gt; 3D object &amp;gt; Cube로 큐브를 생성하면 Scale이 (1, 1, 1)의 큐브가 생성된다. Scale을 (10, 1, 1)로 설정해 쭉 늘어진 기둥을 만든 뒤 Position 값을 조절해 바닥의 양 모서리에 위치시키자. 한번 만든 Cube 오브젝트는 복사 - 붙여넣기로 간편하게 복제할 수 있다 .&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1167&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153203608-a3a26a51-fe8e-4d34-8280-2effa087c262.png&quot; /&gt;
벽 제작
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 레벨로 오브젝트 관리&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이렇게 만들고나니 Hierarchy 창이 좀 복잡하다. 보기 간편하게 정리해보자.&lt;/p&gt;

&lt;p&gt;Hierarchy &amp;gt; Create &amp;gt; Empty Object로 빈 오브젝트를 만든 뒤 만들었던 Plane과 Wall들을 생성한 빈 오브젝트에 Drag &amp;amp; Drop으로 자식으로 만들어주자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153204100-577cb5cf-226a-4aaa-99cf-ad359d659c59.png&quot; /&gt;
깔끔해진 Hierarchy 창
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 카메라 설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 플레이시에 보일 화면을 설정해보자.&lt;/p&gt;

&lt;p&gt;Hierarchy창에 있는 Main Camera 오브젝트를 눌러 Inspector창을 설정하자.&lt;/p&gt;

&lt;p&gt;Position값을 (0, 15, -10), Rotation값을 (60, 0, 0)으로 설정하면 한눈에 화면이 눈에 들어오게 카메라 뷰를 세팅할 수 있다.&lt;/p&gt;

&lt;p&gt;배경색도 어색하므로 Inspector &amp;gt; Camera &amp;gt; Clear Flags의 값을 Solid Color로 바꿔 단색으로 설정해주자.&lt;/p&gt;

&lt;p&gt;이렇게 기본적인 게임의 틀인 씬의 레벨과 카메라 설정을 완료했다.&lt;/p&gt;

&lt;h2 id=&quot;플레이어-제작&quot;&gt;플레이어 제작&lt;/h2&gt;

&lt;p&gt;이제 스크립트를 이용해 조작할 수 있는 게임 오브젝트인 플레이어를 만들어보자.&lt;/p&gt;

&lt;p&gt;이 게임에서 플레이어는 다음과 같은 동작을 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파란색 캡슐 모양이다.&lt;/li&gt;
  &lt;li&gt;상하좌우 혹은 WASD키로 움직인다.&lt;/li&gt;
  &lt;li&gt;탄알에 맞으면 죽는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;플레이어 게임 오브젝트 만들기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hierarchy &amp;gt; Create &amp;gt; 3D Object &amp;gt; Capsule로 캡슐형태의 오브젝트를 만들고 이름을 “Player”로 설정하자. 머티리얼을 통해 파란색으로 플레이어 오브젝트 색깔을 설정해주자.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1673&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153624920-200afa88-d0ee-4cb8-b008-78628b56db7f.png&quot; /&gt;
플레이어 오브젝트 생성
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;태그 설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;나중에 탄알을 만들 때 탄알 입장에서 충돌한 게임 오브젝트가 플레이어인지 아닌지 확인하기 위해 “태그(Tag)”를 사용한다.&lt;/p&gt;

&lt;p&gt;태그는 게임 오브젝트를 분류하고, 코드상으로 오브젝트끼리 구별할 때 사용한다.&lt;/p&gt;

&lt;p&gt;생성한 “Player”오브젝트의 Inspector창 &amp;gt; Tag 드롭다운메뉴 &amp;gt; Player 선택&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153625697-62948f51-cf5e-49f1-a43d-58c19d8c1cf2.png&quot; /&gt;
플레이어 오브젝트의 태그를 &quot;Player&quot;로 설정
&lt;/p&gt;

&lt;p&gt;이렇게 설정하면 나중에 총알 오브젝트가 다른 오브젝트와 충돌할 때 “Player”의 태그인 오브젝트를 구별할 수 있어 게임오버를 판별할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;리지드바디 컴포넌트 설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 플레이어가 움직이거나 총알과 부딪히는 등 물리적인 법칙에 지배받게 하기 위해 리지드바디 컴포넌트를 플레이어 오브젝트에 추가해보자.&lt;/p&gt;

&lt;p&gt;플레이어 오브젝트의 Inspector창 &amp;gt; Add Component &amp;gt; Physics &amp;gt; Rigidbody로 리지드바디 컴포넌트를 플레이어 게임 오브젝트에 추가해보자&lt;/p&gt;

&lt;p&gt;이상태 그대로 두면 플레이어는 캡슐모양이기에 이리저리 굴러다니게 된다.
리지드바디의 제약(Constraints)옵션을 사용해 어떤 축의 위치나 회전이 변경되지 않게 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;플레이어 오브젝트의 Inspector창 &amp;gt; Rigidbody 컴포넌트 창 &amp;gt; Constraints &amp;gt; Freeze Position의 Y 체크, Freeze Rotation의 X, Z 체크&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1342&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/153692792-f10f664d-7696-4b62-b2a0-1230ba2c2e57.png&quot; /&gt;
리지드바디 컴포넌트 추가 및 제약 설정
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;플레이어 스크립트 생성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 플레이어를 조종하기 위한 스크립트 파일을 만들어야 한다. 플레이어 스크립트는 다음과 같은 기능을 가진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사용자의 키보드 입력 감지&lt;/li&gt;
  &lt;li&gt;리지드 바디를 사용하여 Player 게임 오브젝트 움직이기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PlayerColtroller 스크립트 파일을 만들어 위의 기능을 구현해보자.&lt;/p&gt;

&lt;p&gt;게임오브젝트의 이동을 구현할 때 물리적인 힘들 가하는 방식을 사용할 것이다. 따라서 PlayerController 스크립트에 Player 게임 오브젝트에 추가된 리지드바디 컴포넌트를 변수로 가져와 사용해야 한다. 리지드바디 컴포넌트를 할당할 변수와 이동 속력을 지정할 변수를 선언해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour
{   
    public Rigidbody playerRigidBody; //이동에 사용할 리지드바디 컴포넌트
    public float speed = 8f; //이동 속력 

    void Start()
    {
        
    }


    void Update()
    {
        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;나중에 이 playerRigidbody 변수를 통해 Rigidbody 컴포넌트를 지닌 오브젝트를 가리켜서 조종할 수 있다. 즉 playerRigidbody 변수에 Player 오브젝트의 리지드바디 컴포넌트를 지정해 사용할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사용자 입력 감지&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 입력을 감지하는 기능을 만들자. 입력을 감지하려면 Update() 메서드와 Input 클래스의 입력 감지 메서드를 활용할 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Update() 메서드 &lt;br /&gt; 게임속의 모든 정보는 실시간으로 변한다. 인공지능 적이 플레이어를 추적하는 등의 작업에서 이렇게 실시간으로 변한느 정보를 계속해서 모니터링 하는 작업이 필요하다. 대부분 게임은 주기적으로 이러한 갱신 처리를 진행하며 보통 화면이 새로 그려지는 주기인 프레임(Frame)에 맞춰 실행된다. &lt;br /&gt; Update() 메서드는 Start() 메서드처럼 특정 시점에 자동으로 실행되는 유니티 이벤트 메서드이며 매 프레임마다 실행되는 메서드이다. 만약 60FPS라면 1초마다 60번 update() 메서드가 실행되는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Input 클래스 &lt;br /&gt; 유니티 Input 클래스는 사용자의 입력을 감지하는 메서드를 모아둔 집합이다. Input의 입력감지 메서드는 실행 시점에 어떤 키를 눌렀는지 알려준다. &lt;br /&gt; Update() 메서드는 1초에 수십 번씩 실행되므로 Update()메서드에 입력 감지 메서드를 사용하면 매우 짧은 간격으로 입력을 받을 수 있고 게임 유저는 실시간으로 입력을 받아들인다고 인식할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;update()메서드를 다음과 같이 바꾸자&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Update()
{
    if (Input.GetKey(KeyCode.UpArror) == ture){
        //위쪽 방향키 입력이 감지된 경우 z 방향 힘 주기
        playerRigidBody.AddForce(0f, 0f, speed);
    }
    if (Input.GetKey(KeyCode.DownArror) == ture){
        //아래쪽 방향키 입력이 감지된 경우 -z 방향 힘 주기
        playerRigidBody.AddForce(0f, 0f, -speed);
    }
    if (Input.GetKey(KeyCode.RightArror) == ture){
        //오른쪽 방향키 입력이 감지된 경우 x방향 힘 주기
        playerRigidBody.AddForce(Speed, 0f, 0f);
    }
    if (Input.GetKey(KeyCode.LeftArror) == ture){
        //왼쪽 방향키 입력이 감지된 경우 -x방향 힘 주기
        playerRigidBody.AddForce(-speed, 0f, 0f);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 상하좌우 방향키의 입력을 감지하고 게임 오브젝트에 힘을 가해 해당 방향으로 이동시킨다.&lt;/p&gt;

&lt;p&gt;Input.GetKey() 메서드는 키보드의 식별자를 KeyCode 타입의 변수로 입력받는다.&lt;/p&gt;

&lt;p&gt;`
bool Input.GetKey(KeyCode key);
`&lt;/p&gt;

&lt;p&gt;위의 메서드가 실행될 때 해당 키를 누르고 있으면 True, 아니면 False를 반환한다. 
4종류의 키를 감지하는 4개의 Input.GetKey() 메서드가 1초에 수십번씩 실행되고 있으므로 실시간으로 입력을 감지할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;이 외에도&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input.GetKeyDown() // 해당 키를 누르는 '순간' true, 나머지는 false
Input.GetKeyUp() // 해당 키를 누르다가 손을 떼는 '순간' true, 나머지는 false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;의 메서드들도 있다. 위의 2개의 메서드들은 Input.GetKey() 메서드와 달리 ‘누르고 있는 동안’은 false를 반환한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;내용이-길어지므로-다음-글에서-player-게임-오브젝트의-설정을-마무리하겠다&quot;&gt;내용이 길어지므로 다음 글에서 Player 게임 오브젝트의 설정을 마무리하겠다.&lt;/h3&gt;</content><author><name>Kim Namsub</name></author><summary type="html">탄막 슈팅 게임 ‘닷지’ - 플레이어 제작</summary></entry><entry><title type="html">Unity programming(4)</title><link href="http://localhost:4000/Unity-Programming(4)/" rel="alternate" type="text/html" title="Unity programming(4)" /><published>2022-02-06T00:00:00+09:00</published><updated>2022-02-06T00:00:00+09:00</updated><id>http://localhost:4000/Unity%20Programming(4)</id><content type="html" xml:base="http://localhost:4000/Unity-Programming(4)/">&lt;h1 id=&quot;5-게임-오브젝트-제어하기&quot;&gt;5. 게임 오브젝트 제어하기&lt;/h1&gt;

&lt;p&gt;객체지향을 이용해 클래스와 오브젝트(객체)를 다뤄보자&lt;/p&gt;

&lt;h2 id=&quot;클래스와-오브젝트&quot;&gt;클래스와 오브젝트&lt;/h2&gt;
&lt;p&gt;게임내에서의 지형, NPC, 몬스터 하나하나는 오브젝트(객체)다. 그리고 이 오브젝트들은 클래스를 통해 하나씩 생성되어 게임 내에서 사용된다.&lt;/p&gt;

&lt;p&gt;즉 객체지향과 동일하다.&lt;/p&gt;

&lt;p&gt;같은 클래스에서 찍어낸 각각의 오브젝트는 물론 다른 클래스에서 나온 오브젝트끼리는 독립성을 지닌다. 한 오브젝트가 어떤 행동할 하거나 죽는 것이 다른 오브젝트에 영향을 미치지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;c-클래스-만들기&quot;&gt;C# 클래스 만들기&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;539&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152676713-029f8572-f07a-4475-84cd-d356d7e63375.png&quot; /&gt;
Unity에서 C# 스크립트 만들기
&lt;/p&gt;

&lt;p&gt;위의 경로를 통해 C# 스크립트를 만들면 유니티의 Asset에 만든 스크립트 파일이 보인다. 해당 스크립트 파일을 클릭하면 IDE를 통해 C# 코드를 작성하고 저장할 수 있다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;480&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152676938-871b6fe1-fa88-42e8-bf15-86b932e743f9.png&quot; /&gt;
C# 스크립트
&lt;/p&gt;

&lt;p&gt;Animal 클래스를 만들고 필드 변수로 이름(name)과 울음소리(sound) 그리고 메서드로 이름과 울음소리를 로그로 찍도록 만들었다.&lt;/p&gt;

&lt;p&gt;현재 MonoBehaviour 클래스를 Animal 클래스가 상속받지 않아 실제 Unity에서 컴포넌트로 만들 수 없다.&lt;/p&gt;

&lt;p&gt;이제 Animal 클래스를 기반으로 Animal 오브젝트를 만드는 Zoo 스크립트를 만들자&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;425&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152685781-0a58248e-7e92-449d-9400-9da2aae0eb68.png&quot; /&gt;
Zoo 클래스
&lt;/p&gt;

&lt;p&gt;Animal 클래스의 객체인 Tom을 만들어 이름과 울음소리를 설정하고 메서드를 실행시키는 스크립트, MonoBehaviour을 상속받으므로 Unity에서 컴포넌트로 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 Hierarchy 창에서 Create &amp;gt; Create empty로 빈 오브젝트를 만들고 만들어진 컴포넌트에 Zoo 스크립트를 Drag&amp;amp;Drop을 하면 컴포넌트로 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 실행을 해보면 console에 로그로 “냐옹!”이 찍히는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1176&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152686020-8520e00c-637d-401f-8dad-62240e30c41c.png&quot; /&gt;
Zoo 컴포넌트를 담은 오브젝트 실행 결과
&lt;/p&gt;

&lt;h2 id=&quot;참조타입에-대한-고찰&quot;&gt;*참조타입에 대한 고찰&lt;/h2&gt;
&lt;p&gt;Tom 말고 Jerry라는 Animal 오브젝트를 Zoo 스크립트안에서 만든 뒤 name을 jerry, sound를 찍찍!으로 설정해보자.&lt;/p&gt;

&lt;p&gt;그리고&lt;/p&gt;

&lt;p&gt;jerry = tom;&lt;/p&gt;

&lt;p&gt;이라는 코드를 입력해보자.&lt;/p&gt;

&lt;p&gt;jerry, tom같은 객체명은 참조타입이기에 jerry, tom이 각각 가지고 있는 멤버들의 메모리 주소를 지니게 된다. jerry와 tom을 통해 해당 메모리에 접근할 수 있는 것이다(포인터처럼)&lt;/p&gt;

&lt;p&gt;jerry = tom;&lt;/p&gt;

&lt;p&gt;jerry.name = “제리”;&lt;/p&gt;

&lt;p&gt;를 실행하면 jerry는 tom의 멤버를 가리키게 되고 그 후 jerry를 통해 name을 수정하게 되면&lt;/p&gt;

&lt;p&gt;tom.name도 “제리”로 변경되게 된다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;538&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152686569-a04b85f6-9a4a-43f3-94ae-4f4e0202ef52.png&quot; /&gt;
위 내용을 담은 Zoo 스크립트 코드
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;433&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152686733-841714e4-c410-4937-b4d4-9dde0b662832.png&quot; /&gt;
스크립트 코드 실행 console 결과
&lt;/p&gt;

&lt;p&gt;그 결과 위의 그림처럼 jerry를 통해 tom의 name이 수정된 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;객체지향의 참조타입(reference type)과 원시타입(primitive type)의 중요한 차이점을 알 수 있는 내용이라 따로 정리해보았다.&lt;/p&gt;

&lt;h2 id=&quot;변수로-컴포넌트-사용하기&quot;&gt;변수로 컴포넌트 사용하기&lt;/h2&gt;

&lt;p&gt;변수의 타입을 참조타입으로 설정하면 변수를 통해 오브젝트와 컴포넌트에 접근해 이들을 조종할 수 있다. 이를 활용해보자&lt;/p&gt;

&lt;p&gt;우선 Hierarchy에서 Create &amp;gt; 3D object &amp;gt; Cube를 통해 큐브 오브젝트를 생성하고 생성한 큐브의 Inspector 창에서 Add component &amp;gt; Physics &amp;gt; Rigidbody 컴포넌트를 추가해 물리법칙에 영향을 받도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;변수로-rigidbody-컴포넌트-사용하기&quot;&gt;변수로 Rigidbody 컴포넌트 사용하기&lt;/h3&gt;
&lt;p&gt;참조타입의 변수로 오브젝트를 가리킬 수 있다.&lt;/p&gt;

&lt;p&gt;즉, Rigidbody 타입의 변수는 Rigidbody 컴포넌트를 가진 오브젝트를 가리키고 다룰 수 있다. (이를 통해 유니티의 컴포넌트들은 클래스로 만들어져 있다는 것을 알 수 있다!)&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;450&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152688425-75594778-cfbb-40e7-a70e-e6671b6b69a0.png&quot; /&gt;
Jumper 스크립트
&lt;/p&gt;

&lt;p&gt;Jumper C# 스크립트를 만들고 rigidbody 타입의 변수 myRigidBody를 만들어 AddForce 메서드를 실행하는 코드다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;450&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/152688643-b248ea81-1684-4753-9363-86ac3cbddbe2.png&quot; /&gt;
추가한 Jumper 컴포넌트에 오브젝트 할당
&lt;/p&gt;

&lt;p&gt;이렇게 추가했으면 Jumper 스크립트의 컴포넌트를 Inspector창에서 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;스크립트상으로 public으로 선언된 변수는 Inspector창에서 만질 수 있는데 myRigidBody변수는 public이었으므로 Inspector창에 표시된다.&lt;/p&gt;

&lt;p&gt;myRigidBody.Addforce();&lt;/p&gt;

&lt;p&gt;위의 코드는 변수 myRigidBody가 가리키는 오브젝트에 접근해 Addforce() 메서드를 실행하는 코드인데 현재 아무런 오브젝트도 myRigidBody 변수에 할당되어 있지 않으므로 에러가 난다.&lt;/p&gt;

&lt;p&gt;위의 그림처럼 Cube 오브젝트와 Jumper 컴포넌트의 Rigidbody타입 변수에 할당해주면 정상적으로 실행된다.&lt;/p&gt;

&lt;p&gt;즉 위처럼 Jumper 스크립트의 myRigidBody변수에서 실제 큐브 오브젝트의 Rigidbody 컴포넌트로 향하는 참조가 할당된다.&lt;/p&gt;

&lt;p&gt;여기서는 변수 myRigidBody가 실제로 사용되는 것이 아니라 myRigidBody가 가리키는 실체(큐브 오브젝트의 Rigidbody 컴포넌트)가 사용된다는 점에 주목하자.&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">5. 게임 오브젝트 제어하기</summary></entry><entry><title type="html">Unitiy programming(3)</title><link href="http://localhost:4000/Unitiy-Programming(3)/" rel="alternate" type="text/html" title="Unitiy programming(3)" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/Unitiy%20Programming(3)</id><content type="html" xml:base="http://localhost:4000/Unitiy-Programming(3)/">&lt;h1 id=&quot;2-상속과-컴포넌트&quot;&gt;2. 상속과 컴포넌트&lt;/h1&gt;

&lt;p&gt;유니티는 기본적인 객체지향(OOP)의 특성인 상속과 게임 오브젝트 구성을 위해 상속보다 더 효과적인 컴포넌트 패턴이라는 것을 지원한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;상속&quot;&gt;상속&lt;/h3&gt;
&lt;p&gt;일반적인 객체지향에서의 상속과 동일하다. 부모클래스의 메소드와 필드를 자식개체가 물려받아 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;다만 Human 클래스를 만들어 이를 바탕으로 다양한 NPC를 만들고 몬스터 오브젝트를 만들려고 하면 인간 종족이 아닌 슬라임, 늑대인간 등 Human 클래스의 활용도가 현저히 떨어지는 상황이 게임을 개발하는 상황에서는 자주 발생한다.&lt;/p&gt;

&lt;p&gt;Human 클래스에서 인간에 맞춰 움직임과 그 그래픽, 상호작용을 구성해놨는데 이를 슬라임 등 다른 오브젝트에 사용하려고 하면 모두 다 메소드 오버로딩 등 재정의하거나 변경해야 하기에 그 효율이 떨어지는 것이다.&lt;/p&gt;

&lt;p&gt;즉, 상속만으로 게임개발을 하면&lt;br /&gt;
&lt;strong&gt;1. 오히려 코드의 재사용을 하기 힘든 경우가 발생&lt;/strong&gt; - 위의 경우 Slime, Warewolf 클래스 등 여러 클래스를 개별적으로 만들어줘야 함&lt;br /&gt;
&lt;strong&gt;2. 기획자가 새로운 오브젝트를 만들려면 프로그래머에게 의존해야 함&lt;/strong&gt; - 코드 수준에서만 부모 클래스를 확장하거나 자식 클래스에서 오버로딩 등을 할 수 있기에 다른 팀원이 접근하기 어려움&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 문제를 해결하기 위해 유니티는 ‘컴포넌트 패턴’을 활용한 개발을 지원한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;컴포넌트-패턴&quot;&gt;컴포넌트 패턴&lt;/h3&gt;
&lt;p&gt;게임 엔진에서 ‘오브젝트’는 게임 세상에 존재하는 하나의 물체이다. 유니티에서는 이 오브젝트를 ‘컴포넌트’를 사용해 만든다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Component (or Composition) 패턴&lt;/strong&gt; - 미리 만들어진 부품을 조립하여 물건을 만드는 것 처럼 이미 만들어진 컴포넌트들을 조합해 오브젝트를 만들어 나가는 방법&lt;/p&gt;

&lt;p&gt;기획자가 처음부터 게임에 등장할 모든 동물을 예상할 수 없기에 개발자는 공통적으로 쓰일 개별적인 컴포넌트를 만들어 둔다. 예를들어 팔, 다리, 아가미, 입, 코, 지느러미, 잠자기, 움직이기, 날개, 식사 등 독자적으로 쓰일 수 있는 것들을 만들어 둔다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;게임-오브젝트와-컴포넌트의-특징&quot;&gt;게임 오브젝트와 컴포넌트의 특징&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1. 유연한 재사용이 가능&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;2. 기획자의 프로그래머에 대한 의존성 감소&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;3. 뛰어난 독립성 덕분에 기능 추가와 삭제가 용이&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3-1. 게임 오브젝트는 단순한 껍데기&lt;/strong&gt; - 게임 오브젝트는 몇 가지의 식별기능과 어떠한 컴포넌트가 자신을 구성하고 있는지를 제외하고는 별다른 기능이 없음&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3-2. 컴포넌트는 개별적으로 작동하는 독립 부품임&lt;/strong&gt; - 컴포넌트는 다른 컴포넌트와 상관이 없음. 각 컴포넌트는 스스로 이미 완성되어 있기 때문에 한 오브젝트에서 컴포넌트를 추가 및 삭제해도 서로 충돌을 일으키거나 망가지지 않음&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;컴포넌트-추가-및-삭제&quot;&gt;컴포넌트 추가 및 삭제&lt;/h1&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img width=&quot;1113&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/68016394/151705862-d8baa08e-2389-4847-b0aa-6974fe5f5fbb.png&quot; /&gt;
Cube 오브젝트와 이를 구성하는 컴포넌트들
&lt;/p&gt;

&lt;p&gt;위의 그림에서 Cube같은 오브젝트를 클릭하면 옆의 Inspector창에 선택한 오브젝트를 구성하는 컴포넌트들을 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;예를들어 Box collider 컴포넌트를 삭제하면 박스의 물리적 표면이 사라져 다른 물체와 충돌하지 않는다. 그리고 Rigidbody를 추가해 해당 오브젝트가 중력의 영향을 받도록 만들었다. 이 상태에서 Box collider 컴포넌트를 삭제하면 물리적 표면은 없지만 중력의 영향은 받기에 영원히 아래로 떨어지게 된다.&lt;/p&gt;

&lt;p&gt;즉 위에서 살펴보았던 것 처럼 컴포넌트 끼리의 독립성이 유지되는 것이다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;메시지와-브로드캐스팅&quot;&gt;메시지와 브로드캐스팅&lt;/h1&gt;

&lt;h2 id=&quot;monobehaviour&quot;&gt;MonoBehaviour&lt;/h2&gt;
&lt;p&gt;유니티의 모든 컴포넌트는 MonoBehaviour이라는 클래스를 상속받는다. 이 클래스는 유니티에서 미리 만들어 제공하는 클래스이며 컴포넌트에 필요한 필수적이고 기본적인 기능을 제공한다. 이를 상속한 컴포넌트만이 게임 오브젝트의 컴포넌트로서 사용될 수 있는 것이다. (파이썬의 self같은 느낌…?)&lt;/p&gt;

&lt;p&gt;그리고 이렇게 MonoBehaviour을 상속받은 컴포넌트는 유니티의 제어를 받게 되기에 유니티에서 보내는 메시지를 들을 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;broadcasting&quot;&gt;Broadcasting&lt;/h2&gt;
&lt;p&gt;유니티가 메시지를 보내면 컴포넌트들은 해당 메시지에서 호출된 메서드를 실행한다. 유니티는 메시지를 보낼 때 누가 받을지 상관하지 않으며 마찬가지로 컴포넌트들도 누가 보낸 메시지인지 신경쓰지 않는다. 그저 메시지에 적힌 메서드를 내가 가지고 있다면 실행하고 없다면 무시할 뿐이다.&lt;/p&gt;

&lt;p&gt;dance()라는 메서드를 실행하라는 메시지를 유니티가 컴포넌트들에게 방송하면 해당 메서드를 가지고 있는 컴포넌트들은 이에 반응하여 해당 메서드를 실행하고 그렇지 않는 컴포넌트들은 이를 무시한다.&lt;/p&gt;

&lt;h2 id=&quot;유니티-이벤트-메서드&quot;&gt;유니티 이벤트 메서드&lt;/h2&gt;
&lt;p&gt;위의 내용은 앞으로 많이 사용할 Start(), Update(), OnTriggerEnter()와 같은 ‘유니티 이벤트 메서드’가 동작하는 원리다. (이는 Unity programming(4)에서 다룰 예정)&lt;/p&gt;

&lt;p&gt;예를 들어 Start() 메서드는 오브젝트가 처음 활성화 될 때 자동으로 한번 실행되는데 이는 유니티가 Start라고 적힌 메서드를 자동으로 브로드캐스팅하기에 사용자가 명시적으로 호출할 필요가 없는 것이다.&lt;/p&gt;

&lt;p&gt;유니티에서는 이런 식으로 이름 철자만 똑같이 구현해두면 메시지와 브로드캐스팅에 의해 자동으로 실행되는 메서드들이 존재하고 이를 ‘유니티 이벤트 함수’ 혹은 ‘유니티 이벤트 메서드’라고 한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;요약&quot;&gt;요약&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1. 게임 오브젝트는 컴포넌트를 담는 단순한 빈 껍데기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 빈 게임 오브젝트에 컴포넌트를 붙여 기능을 추가한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 컴포넌트는 기능을 가진 부품으로 오브젝트에 이식되어 조립된다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 각 컴포넌트는 서로 독립적으로 작동한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 유니티의 모든 컴포넌트는 MonoBehaviour을 상속받아 만들어진다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 메시지를 받은 컴포넌트는 메시지에 표시된 메서드를 가지고 있으면 실행한다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 브로드캐스팅은 메시지를 무차별적으로 모든 컴포넌트에게 뿌리는 행위이다&lt;/strong&gt;&lt;/p&gt;</content><author><name>Kim Namsub</name></author><summary type="html">2. 상속과 컴포넌트</summary></entry></feed>