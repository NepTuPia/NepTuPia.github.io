# 2D 러너 게임 '유니런' 제작 - 배경 스크롤링과 게임 매니저(1)

이번에는 움직이는 배경과 발판을 만들어보자. 캐릭터가 뛰어 앞으로 전진하는 것처럼 보이지만 실제로 x축 값은 고정되어 있고, 배경과 발판이 움직여 캐릭터를 향해 다가오는 것 뿐이다. 

## 배경 추가하기

스프라이트 폴더에 있는 'Sky'파일을 하이어라키 창으로 넣어 오브젝트로 추가하자. 그리고 Main Camera 오브젝트를 클릭해 배경색을 설정하자.

메인 카메라 오브젝트의 Inspector 창에서 'Clear Flags'를 'Solid Color'로 설정하고, 아래 'Background'에서 색깔을 옆에 있는 스포이트를 사용해 아까 추가한 Sky의 배경색을 선택해 일관된 배경이 깔리게 하자.

![image](https://user-images.githubusercontent.com/68016394/160810702-684af82f-b060-4f1e-a960-936489dfc239.png)

다시 씬을 살펴보면 조금 이상하다. Sky 오브젝트에 가려져 만들어둔 캐릭터와 시작발판이 보이지 않는다. 이를 위해 이제 '정렬 레이어'를 설정해줘야 한다.

**정렬 레이어 설정**

스프라이트 렌더러 컴포넌트가 그리는 그래픽의 앞뒤 정렬 순서는 그래픽 오브젝트의 위치값과는 상관이 없다. 스프라이트 렌더러의 '정렬 레이어(Sorting Layer)'가 결정한다. 

우선 정렬하기 위해 사용할 정렬 레이어를 게임 오브젝트에 있는 스프라이트 렌더러 컴포넌트에 추가하자. 스프라이트 렌더러 컴포넌트의 Inspector창에서 'Sorting Layer' > 'Add Sorting Layer...' 를 하면 새로운 창이 뜬다. 'Sorting Layers'에서 '+' 버튼을 눌러 레이어를 새로 생성하고 이름을 적절히 설정하면 된다. 이제 아래와 같이 레이어들을 추가해주자.

![image](https://user-images.githubusercontent.com/68016394/161896436-deddf7dd-6450-4672-aecd-fa4a60291803.png)

'Sky' 오브젝트의 스프라이트 렌더러를 통해 3개의 레이어를 만들었다. 그러면 이제 다른 오브젝트의 스프라이트 렌더러에서도 만들어둔 레이어들을 사용할 수 있다. 

유니티에서는 가장 위쪽에 있는 레이어가 가장 뒤쪽에 그려진다. 이를 유념해서 오브젝트의 레이어를 설정해주자. 플레이어 오브젝트는 Foreground, 발판 오브젝트는 Middleground, 배경 오브젝트는 Backgroun로 레이어를 설정해주면 아래와 같이 깔끔하게 정렬된다. 

![image](https://user-images.githubusercontent.com/68016394/161896700-736549ef-295a-4c33-86d7-0555bbe42c3d.png)

## 움직이는 배경과 발판

배경까지 그렸으므로 이제 캐릭터가 움직이도록 만들어야 한다. 앞에서 얘기했듯이 캐릭터가 직접 움직이지 않고 배경과 발판이 움직여 마치 캐릭터가 앞으로 전진하듯이 보이게 처리할 것이다.

'ScrollingObject' 스크립트를 만들어 오브젝트에 추가하여 구현해보자. C# 스크립트를 'scripts' 폴더에 에셋으로 추가하고 발판 오브젝트와 배경 오브젝트에 컴포넌트로 추가하자. 그 뒤에 아래처럼 코드를 완성하자.

```
using UnityEngine;

// 게임 오브젝트를 계속 왼쪽으로 움직이는 스크립트
public class ScrollingObject : MonoBehaviour {
    public float speed = 10f; // 이동 속도

    private void Update() {
        // 게임 오브젝트를 왼쪽으로 일정 속도로 평행 이동하는 처리
        transform.Translate(Vector3.left * speed * Time.deltaTime);
    }
}
```

간단하다. Update() 메서드 안에 매 프레임마다 일정 속도로 평행이동하는 코드를 추가했다. 앞에서도 사용했지만 Translate() 메서드는 평행이동을 구현하는 메서드였다. 

Translate() 메서드는 Vector3 타입의 값을 파라미터로 받는다. 그리고 Vector3.left는 (-1, 0, 0)을 의미한다. 그러므로 최종적으로 Translate() 메서드에 들어가는 파라미터는 (-speed, 0, 0)에 단위시간을 곱한것이 되어 일정한 속도로 움직이게 된다. 

이제 게임을 플레이해보면 배경과 발판이 움직일 것이다! 하지만 계속 생성되지 않기 때문에 얼마 못가 캐릭터는 떨어져 게임이 끝나고 만다. 일단 배경이 계속 반복되게 만들어보자.

**반복되는 배경 만들기**

계속해서 배경을 생성하는것이 아니라 컨베이어 벨트처럼 하나의 오브젝트가 반복해서 화면에 나타나도록 만들것이다. 배경 오브젝트의 x축 위치를 계속해서 파악하면서 오브젝트의 가로길이 'width'를 벗어나면 화면을 벗어난 것이므로 x축 위치를 다시 화면의 오른쪽으로 보내 다시 재생되도록 할 것이다. 

width값을 얻기 위해서는 'Box Collider 2D' 컴포넌트를 추가해 얻을 수 있다. 그리고 배경 오브젝트가 다른 오브젝트와 물리적으로 상호작용하면 안되므로 트리거 오브젝트르 만들어주자. 

![image](https://user-images.githubusercontent.com/68016394/161900996-f9738e78-4803-4fea-974c-f78011eeb261.png)

이제 스크립트를 추가해 의도한대로 작동하도록 만들자. 'BackgroundLoop' 스크립트를 만들어 아래와 같이 코드를 작성하고 오브젝트에 컴포넌트로 추가하자.

```
using UnityEngine;

// 왼쪽 끝으로 이동한 배경을 오른쪽 끝으로 재배치하는 스크립트
public class BackgroundLoop : MonoBehaviour {
    private float width; // 배경의 가로 길이

    private void Awake() {
        // 가로 길이를 측정하는 처리
        BoxCollider2D backgroundCollider = GetComponent<BoxCollider2D>();
        width = backgroundCollider.size.x;
    }

    private void Update() {
        // 현재 위치가 원점에서 왼쪽으로 width 이상 이동했을때 위치를 리셋
        if(transform.position.x <= -width){
            Reposition();
        }
    }

    // 위치를 리셋하는 메서드
    private void Reposition() {
        Vector2 offset = new Vector2(width * 2f, 0);
        transform.position = (Vector2) transform.position + offset;
    }
}
```

Awake() 메서드는 Start() 메서드처럼 1회만 실행되는 메서드지만 Start() 메서드보다 1프레임 실행이 빠르다. Awake() 메서드를 통해 오브젝트의 가로길이 width 값을 할당해준다. 

그 뒤에 Update() 메서드를 통해 오브젝트가 화면밖을 벗어났는지 검사한다. 벗어났다면 Respotition() 메서드를 실행해 위치를 리셋한다. 

Reposition() 메서드를 잘 살펴보자. offset 변수에는 오브젝트 가로길이의 2배만큼 오른쪽으로 떨어져있는 위치를 가지게 된다. 그리고 오브젝트의 position에 접근해 현재 오브젝트의 위치에 offset을 더해주어 배경의 위치를 다시 셋팅해 배경이 무한히 반복되게 했다. 

transform.position은 기본적으로 Vector3 타입이기에 offset과 더할 수 없기에 (Vector2)로 형변환을 해준 것이다. Vector3와 Vector2는 원시 타입이 아니기에 자동 형변환이 일어나지 않는다! 반드시 형변환을 명시적으로 잘 해주자.  

이제 배경 오브젝트를 Ctrl+D로 복사해서 위치를 (20.48, 0, 0)으로 셋팅해 하나 더 만들자. 그리고 빈 오브젝트를 만들어 두 배경 오브젝트를 자식 오브젝트로 만들어 정리하면 무한히 반복되는 배경이 완성되었다!

![image](https://user-images.githubusercontent.com/68016394/161902691-26e721e8-3ec5-4ad7-805a-112d25ddb3ad.png)

##게임 UI 제작

이제 게임내에 게임 오버, 시간, 점수등을 띄울 UI를 만들어 보자. 게임 UI는 'Canvas' 오브젝트를 만들어 띄울 것이다. 우선 고려해야할 것은 게임이 작동될 모니터의 해상도에 따라 어떻게 UI가 변할 것이냐다.

어느 해상도에서든 잘 작동되게 할려면 화면 해상도가 늘어나거나 줄어듬에 따라 적절한 비율대로 오브젝트들도 늘어나거나 줄어들어야 한다. 유니티에서는 크게 2개의 해상도 조절 모드를 제공한다. 해상도와 상관없이 처음 셋팅된대로 고정된 픽셀값을 유지하는 '고정 픽셀 모드(Constant Pixel Size)'와 화면 비율에 따라 적절히 크기가 조절되는 '화면 크기에 따라 스케일(Scale With Screen Size)' 모드이다.

**고정 픽셀 크기 모드**

UI들은 캔버스에 그려진다. 그리고 캔버스의 크기는 실행될 모니터의 해상도를 따라간다. 아래에서처럼 Hierarchy > UI > Canvas로 캔버스 오브젝트를 만들고 Inspector창에서 'Canvas Scaler' 컴포넌트를 보면 'UI Scale Mode'로 스케일 모드를 설정할 수 있다. 

![image](https://user-images.githubusercontent.com/68016394/161967583-964cbd49-b286-40ec-b391-125447605eda.png)

이 상태에선 캔버스 위에 그려질 오브젝트들은 처음 설정된 해상도가 그대로 유지된다. 그러므로 만약 1280 X 900 크기에 맞춰 적절히 오브젝트를 설정했다면, 600 X 400의 해상도에서는 UI 오브젝트들이 과하게 크게 보이게 된다.

이를 위해 화면 크기 즉 캔버스 해상도에 따라 오브젝트들의 크기가 적절히 조절되도록 해보자

**화면 크기에 따른 스케일 조절 모드**

위의 'UI Scale Mode'를 'Scale With Screen Size'로 바꾸면 해상도에 따라 오브젝트들의 크기가 조절되도록 할 수 있다. 바꾸면 'Reference Resolution'에서 기준 해상도를 설정할 수 있다. 화면 크기가 무엇이든간에 설정한 기준 해상도에 따라 캔버스와 오브젝트가 그려지게 된다.

하지만 한가지 문제가 있다. 화면 해상도 비율과 오브젝트들의 가로세로 비율이 일치한다면 그대로 늘리거나 줄이면 되지만 비율이 다르다면 간단하지가 않다. 이를 위해 'Match'라는 옵션을 제공한다. 'Width(가로)'와 'Height(세로)' 사이의 값을 1~0 사이로 조절할 수 있다. 

설명하려면 복잡하지만 매치값이 더 큰쪽의 길이를 보존하도록 작동한다. Width 매치값을 크게 줬으면 가로길이보다는 세로길이가 더 크게 조절된다. 그러므로 가로 방향으로 오브젝트들이 많이 나열되어 있다면 Height의 매치값을 작게 주어 가로길이 변화가 적도록 하여 서로 겹치는 등의 UI 배치가 망가지는 일이 일어나지 않도록 하자!

**UI 텍스트 오브젝트 추가**

이제 컨버스를 만들고 UI 오브젝트들을 띄어보자! 바탕이 될 컨버스 오브젝트는 Reference Resolution을 640 x 360으로 주자.
 
이제 점수, 게임오버, 재시작 메시지를 담을 Text 오브젝트를 만들자. Hierarchy > UI > Text를 눌러 오브젝트를 추가하면 자동으로 아까 생성해둔 'Canvas' 오브젝트의 자식 오브젝트로 들어간다. 
 
 Rect Transform 컴포넌트에서 앵커 프리셋과 Width, Height를 적절히 조절히 위치와 크기를 설정하고 Text 컴포넌트에서 출력할 문자열과 크기, 색상과 폰트를 설정하자.
 
 게임오버 텍스트의 자식으로 재시작 텍스트를 넣어주면 게임오버 텍스트의 활성화/비활성화에 따라 재시작 텍스트도 같이 작동한다. 그러므로 자식 오브젝트로 만들어주고 게임오버 텍스트를 비활성화 해주어 다음에 제작할 게임 매니저가 게임 오버시에 텍스트를 활성화할 수 있도록 만들자.
 
 완성하면 다음과 같다.
 
![image](https://user-images.githubusercontent.com/68016394/161971589-cadeb5cf-bb2d-4b8c-9070-cec94b4ad44e.png)
 
이제 이 UI들과 오브젝트들을 담당할 게임 매니저를 만들어보자!
 
